<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>yaze: Dungeon Graphics Rendering Pipeline Analysis</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../yaze.ico"/></td>
  <td id="projectalign">
   <div id="projectname">yaze<span id="projectnumber">&#160;0.3.1</span>
   </div>
   <div id="projectbrief">Link to the Past ROM Editor</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/dbe/md_docs_2dungeon__graphics__pipeline__analysis.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dungeon Graphics Rendering Pipeline Analysis</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md554"></a> </p>
<h1><a class="anchor" id="autotoc_md555"></a>
Overview</h1>
<p>This document provides a comprehensive analysis of how the YAZE dungeon editor renders room graphics, including the interaction between bitmaps, arena buffers, palettes, and palette groups.</p>
<h1><a class="anchor" id="autotoc_md556"></a>
Architecture Diagram</h1>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                         ROM Data                                 │</div>
<div class="line">│ ┌────────────────────────┐ ┌──────────────────────────────────┐│</div>
<div class="line">│ │ Room Headers           │ │ Dungeon Palettes                 ││</div>
<div class="line">│ │  - Palette ID          │ │  - dungeon_main[id][180 colors] ││</div>
<div class="line">│ │  - Blockset ID         │ │  - sprites_aux1[id][colors]      ││</div>
<div class="line">│ │  - Spriteset ID        │ │  - Palette Groups                ││</div>
<div class="line">│ │  - Background ID       │ │                                  ││</div>
<div class="line">│ └────────────────────────┘ └──────────────────────────────────┘│</div>
<div class="line">└───────────────────────────┬─────────────────────────────────────┘</div>
<div class="line">                            │</div>
<div class="line">                            ▼</div>
<div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                  Room Loading (room.cc)                          │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  LoadRoomFromRom() →  LoadRoomGraphics() → Copy RoomGraphics   │</div>
<div class="line">│    ├─ Load 16 blocks (graphics sheets)                          │</div>
<div class="line">│    ├─ blocks[0-7]: Main blockset                                │</div>
<div class="line">│    ├─ blocks[8-11]: Static sprites (fairies, pots, etc.)        │</div>
<div class="line">│    └─ blocks[12-15]: Spriteset sprites                          │</div>
<div class="line">└───────────────────────────┬─────────────────────────────────────┘</div>
<div class="line">                            │</div>
<div class="line">                            ▼</div>
<div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│                Graphics Arena (arena.h/.cc)                      │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  ┌──────────────────┐  ┌──────────────────┐                    │</div>
<div class="line">│  │ gfx_sheets_[223] │  │ Background       │                    │</div>
<div class="line">│  │ (Bitmap objects) │  │ Buffers          │                    │</div>
<div class="line">│  │                  │  │  - bg1_          │                    │</div>
<div class="line">│  │  Each holds:     │  │  - bg2_          │                    │</div>
<div class="line">│  │  - Pixel data    │  │                  │                    │</div>
<div class="line">│  │  - SDL Surface   │  │  layer1_buffer_  │                    │</div>
<div class="line">│  │  - SDL Texture   │  │  layer2_buffer_  │                    │</div>
<div class="line">│  │  - Palette       │  │  [64x64 = 4096   │                    │</div>
<div class="line">│  └──────────────────┘  │   tile words]    │                    │</div>
<div class="line">│                        └──────────────────┘                    │</div>
<div class="line">└───────────────────────────┬─────────────────────────────────────┘</div>
<div class="line">                            │</div>
<div class="line">                            ▼</div>
<div class="line">┌─────────────────────────────────────────────────────────────────┐</div>
<div class="line">│          Room::RenderRoomGraphics() Pipeline                     │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  Step 1: CopyRoomGraphicsToBuffer()                             │</div>
<div class="line">│    └─ Copy 16 blocks to current_gfx16_[32768] buffer           │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  Step 2: DrawFloor() on both BG1 and BG2                        │</div>
<div class="line">│    ├─ Read floor tile IDs from ROM                              │</div>
<div class="line">│    ├─ Create TileInfo objects (id, palette, mirror flags)       │</div>
<div class="line">│    └─ SetTileAt() in background buffers (repeating pattern)     │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  Step 3: RenderObjectsToBackground() ⚠️ NEW                     │</div>
<div class="line">│    ├─ Iterate through tile_objects_                             │</div>
<div class="line">│    ├─ For each object, get its Tile16 array                     │</div>
<div class="line">│    ├─ Each Tile16 contains 4 TileInfo (8x8 tiles)               │</div>
<div class="line">│    ├─ Convert TileInfo → 16-bit word:                           │</div>
<div class="line">│    │    (vflip&lt;&lt;15) | (hflip&lt;&lt;14) | (palette&lt;&lt;10) | tile_id    │</div>
<div class="line">│    └─ SetTileAt() in correct layer (BG1 or BG2)                 │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  Step 4: DrawBackground() on both BG1 and BG2                   │</div>
<div class="line">│    ├─ BackgroundBuffer::DrawBackground(current_gfx16_)          │</div>
<div class="line">│    ├─ For each tile in buffer_[4096]:                           │</div>
<div class="line">│    │    ├─ Extract 16-bit word                                  │</div>
<div class="line">│    │    ├─ WordToTileInfo() → TileInfo                          │</div>
<div class="line">│    │    └─ DrawTile() → Write 8x8 pixels to bitmap_.data_      │</div>
<div class="line">│    └─ bitmap_.Create(512, 512, 8, pixel_data)                   │</div>
<div class="line">│                                                                  │</div>
<div class="line">│  Step 5: Apply Palette &amp; Create/Update Texture                  │</div>
<div class="line">│    ├─ Get dungeon_main palette for this room                    │</div>
<div class="line">│    ├─ bitmap_.SetPaletteWithTransparent(palette, 0)             │</div>
<div class="line">│    ├─ If first time:                                             │</div>
<div class="line">│    │    └─ CreateAndRenderBitmap() → Create SDL_Texture         │</div>
<div class="line">│    └─ Else:                                                      │</div>
<div class="line">│         └─ UpdateBitmap() → Update existing SDL_Texture         │</div>
<div class="line">└─────────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md557"></a>
Component Breakdown</h1>
<h2><a class="anchor" id="autotoc_md558"></a>
1. Arena (gfx/arena.h/.cc)</h2>
<p><b>Purpose</b>: Global graphics resource manager using singleton pattern.</p>
<p><b>Key Members</b>:</p><ul>
<li><code>gfx_sheets_[223]</code>: Array of Bitmap objects (one for each graphics sheet in ROM)</li>
<li><code>bg1_</code>, <code>bg2_</code>: BackgroundBuffer objects for SNES layer 1 and layer 2</li>
<li><code>layer1_buffer_[4096]</code>, <code>layer2_buffer_[4096]</code>: Raw tile word arrays</li>
</ul>
<p><b>Responsibilities</b>:</p><ul>
<li>Resource pooling for SDL textures and surfaces</li>
<li>Batch texture updates for performance</li>
<li>Centralized access to graphics sheets</li>
</ul>
<h2><a class="anchor" id="autotoc_md559"></a>
2. BackgroundBuffer (gfx/background_buffer.h/.cc)</h2>
<p><b>Purpose</b>: Manages a single SNES background layer (512x512 pixels = 64x64 tiles).</p>
<p><b>Key Members</b>:</p><ul>
<li><code>buffer_[4096]</code>: Array of 16-bit tile words (vflip|hflip|palette|tile_id)</li>
<li><code>bitmap_</code>: The Bitmap object that holds the rendered pixel data</li>
<li><code>width_</code>, <code>height_</code>: Dimensions in pixels (typically 512x512)</li>
</ul>
<p><b>Key Methods</b>:</p>
<h3><a class="anchor" id="autotoc_md560"></a>
&lt;tt&gt;SetTileAt(int x, int y, uint16_t value)&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Sets a tile word at tile coordinates (x, y)</span></div>
<div class="line"><span class="comment">// x, y are in tile units (0-63)</span></div>
<div class="line">buffer_[y * tiles_w + x] = value;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md561"></a>
&lt;tt&gt;DrawBackground(std::span&lt;uint8_t&gt; gfx16_data)&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Renders all tiles in buffer_ to bitmap_</span></div>
<div class="line">1. Create bitmap (512x512, 8bpp)</div>
<div class="line">2. For each tile (64x64 grid):</div>
<div class="line">   - Get tile word from buffer_[xx + yy * 64]</div>
<div class="line">   - WordToTileInfo() to extract: id, palette, hflip, vflip</div>
<div class="line">   - DrawTile() writes 64 pixels to bitmap at correct position</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md562"></a>
&lt;tt&gt;DrawFloor()&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Special case: Draws floor pattern from ROM data</span></div>
<div class="line">1. Read 8 floor tile IDs from ROM (2 rows of 4)</div>
<div class="line">2. Repeat pattern across entire 64x64 grid</div>
<div class="line">3. SetTileAt() for each position</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md563"></a>
3. Bitmap (gfx/bitmap.h/.cc)</h2>
<p><b>Purpose</b>: Represents a 2D image with SNES-specific features.</p>
<p><b>Key Members</b>:</p><ul>
<li><code>data_[width * height]</code>: Raw indexed pixel data (palette indices)</li>
<li><code>palette_</code>: SnesPalette object (15-bit RGB colors)</li>
<li><code>surface_</code>: SDL_Surface for pixel manipulation</li>
<li><code>texture_</code>: SDL_Texture for rendering to screen</li>
<li><code>active_</code>, <code>modified_</code>: State flags</li>
</ul>
<p><b>Key Methods</b>:</p>
<h3><a class="anchor" id="autotoc_md564"></a>
&lt;tt&gt;Create(int w, int h, int depth, vector&lt;uint8_t&gt; data)&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Initialize bitmap with pixel data</span></div>
<div class="line">width_ = w;</div>
<div class="line">height_ = h;</div>
<div class="line">depth_ = depth;  <span class="comment">// Usually 8 (bits per pixel)</span></div>
<div class="line">data_ = data;</div>
<div class="line">active_ = <span class="keyword">true</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md565"></a>
&lt;tt&gt;SetPaletteWithTransparent(SnesPalette palette, size_t index)&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Apply palette and make color[index] transparent</span></div>
<div class="line">palette_ = palette;</div>
<div class="line"><span class="comment">// Update surface_-&gt;format-&gt;palette with SDL_Colors</span></div>
<div class="line"><span class="comment">// Set color[index] alpha to 0 for transparency</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md566"></a>
&lt;tt&gt;CreateTexture(SDL_Renderer* renderer)&lt;/tt&gt; / &lt;tt&gt;UpdateTexture()&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Convert surface_ to hardware-accelerated texture_</span></div>
<div class="line">texture_ = SDL_CreateTextureFromSurface(renderer, surface_);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">SDL_UpdateTexture(texture_, <span class="keyword">nullptr</span>, surface_-&gt;pixels, surface_-&gt;pitch);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md567"></a>
4. Room (zelda3/dungeon/room.h/.cc)</h2>
<p><b>Purpose</b>: Represents a single dungeon room with all its data.</p>
<p><b>Key Members</b>:</p><ul>
<li><code>room_id_</code>: Room index (0-295)</li>
<li><code>palette</code>, <code>blockset</code>, <code>spriteset</code>: IDs from ROM header</li>
<li><code>blocks_[16]</code>: Graphics sheet indices for this room</li>
<li><code>current_gfx16_[32768]</code>: Raw graphics data for this room</li>
<li><code>tile_objects_</code>: Vector of RoomObject instances</li>
<li><code>rom_</code>: Pointer to ROM data</li>
</ul>
<p><b>Key Methods</b>:</p>
<h3><a class="anchor" id="autotoc_md568"></a>
&lt;tt&gt;LoadRoomGraphics(uint8_t entrance_blockset)&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Load 16 graphics sheets for this room</span></div>
<div class="line">blocks_[0-7]:   Main blockset sheets</div>
<div class="line">blocks_[8-11]:  Static sprites (fairies, pots, etc.)</div>
<div class="line">blocks_[12-15]: Spriteset sprites</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md569"></a>
&lt;tt&gt;CopyRoomGraphicsToBuffer()&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="comment">// Copy 16 blocks of 2KB each into current_gfx16_[32KB]</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++) {</div>
<div class="line">  <span class="keywordtype">int</span> block = blocks_[i];</div>
<div class="line">  memcpy(current_gfx16_ + i*2048, </div>
<div class="line">         graphics_buffer[block*2048], </div>
<div class="line">         2048);</div>
<div class="line">}</div>
<div class="line">LoadAnimatedGraphics();  <span class="comment">// Overlay animated frames</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md570"></a>
&lt;tt&gt;RenderRoomGraphics()&lt;/tt&gt; ⭐ &lt;strong&gt;Main Rendering Method&lt;/strong&gt;</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Room::RenderRoomGraphics() {</div>
<div class="line">  <span class="comment">// Step 1: Copy graphics data from ROM</span></div>
<div class="line">  CopyRoomGraphicsToBuffer();  </div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Step 2: Draw floor pattern</span></div>
<div class="line">  Arena::Get().bg1().DrawFloor(rom-&gt;vector(), tile_address, </div>
<div class="line">                                tile_address_floor, floor1_graphics_);</div>
<div class="line">  Arena::Get().bg2().DrawFloor(rom-&gt;vector(), tile_address, </div>
<div class="line">                                tile_address_floor, floor2_graphics_);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Step 3: ⚠️ NEW - Render room objects to buffers</span></div>
<div class="line">  RenderObjectsToBackground();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Step 4: Convert tile buffers to bitmaps</span></div>
<div class="line">  Arena::Get().bg1().DrawBackground(span&lt;uint8_t&gt;(current_gfx16_));</div>
<div class="line">  Arena::Get().bg2().DrawBackground(span&lt;uint8_t&gt;(current_gfx16_));</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Step 5: Apply palette and create/update textures</span></div>
<div class="line">  <span class="keyword">auto</span> palette = rom-&gt;palette_group().dungeon_main[palette_id][0];</div>
<div class="line">  <span class="keywordflow">if</span> (!Arena::Get().bg1().bitmap().is_active()) {</div>
<div class="line">    Renderer::Get().CreateAndRenderBitmap(..., Arena::Get().bg1().bitmap(), palette);</div>
<div class="line">    Renderer::Get().CreateAndRenderBitmap(..., Arena::Get().bg2().bitmap(), palette);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    Renderer::Get().UpdateBitmap(&amp;Arena::Get().bg1().bitmap());</div>
<div class="line">    Renderer::Get().UpdateBitmap(&amp;Arena::Get().bg2().bitmap());</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md571"></a>
&lt;tt&gt;RenderObjectsToBackground()&lt;/tt&gt; ⚠️ &lt;strong&gt;Critical New Method&lt;/strong&gt; ✅ &lt;strong&gt;Fixed&lt;/strong&gt;</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Room::RenderObjectsToBackground() {</div>
<div class="line">  <span class="keyword">auto</span>&amp; bg1 = Arena::Get().bg1();</div>
<div class="line">  <span class="keyword">auto</span>&amp; bg2 = Arena::Get().bg2();</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj : tile_objects_) {</div>
<div class="line">    <span class="comment">// Ensure object has tiles loaded</span></div>
<div class="line">    obj.EnsureTilesLoaded();</div>
<div class="line">    <span class="keyword">auto</span> tiles_result = obj.GetTiles();  <span class="comment">// Returns span&lt;const Tile16&gt;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Calculate the width of the object in Tile16 units</span></div>
<div class="line">    <span class="comment">// Most objects are arranged in a grid, typically 1-8 tiles wide</span></div>
<div class="line">    <span class="keywordtype">int</span> tiles_wide = 1;</div>
<div class="line">    <span class="keywordflow">if</span> (tiles.size() &gt; 1) {</div>
<div class="line">      <span class="comment">// Try to determine optimal layout based on tile count</span></div>
<div class="line">      <span class="comment">// Common patterns: 1x1, 2x2, 4x1, 2x4, 4x4, 8x1, etc.</span></div>
<div class="line">      <span class="keywordtype">int</span> sq = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::sqrt(tiles.size()));</div>
<div class="line">      <span class="keywordflow">if</span> (sq * sq == tiles.size()) {</div>
<div class="line">        tiles_wide = sq;  <span class="comment">// Perfect square (4, 9, 16, etc.)</span></div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tiles.size() &lt;= 4) {</div>
<div class="line">        tiles_wide = tiles.size();  <span class="comment">// Small objects laid out horizontally</span></div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// For larger objects, try common widths (4 or 8)</span></div>
<div class="line">        tiles_wide = (tiles.size() &gt;= 8) ? 8 : 4;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Each Tile16 is 16x16 (4 TileInfo of 8x8)</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; tiles.size(); i++) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tile16 = tiles[i];</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Calculate base position using calculated width (in 8x8 units)</span></div>
<div class="line">      <span class="keywordtype">int</span> base_x = obj.x_ + ((i % tiles_wide) * 2);</div>
<div class="line">      <span class="keywordtype">int</span> base_y = obj.y_ + ((i / tiles_wide) * 2);</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Tile16.tiles_info[4] contains the 4 sub-tiles:</span></div>
<div class="line">      <span class="comment">// [0][1]  (top-left, top-right)</span></div>
<div class="line">      <span class="comment">// [2][3]  (bottom-left, bottom-right)</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> sub = 0; sub &lt; 4; sub++) {</div>
<div class="line">        <span class="keywordtype">int</span> tile_x = base_x + (sub % 2);</div>
<div class="line">        <span class="keywordtype">int</span> tile_y = base_y + (sub / 2);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Bounds check</span></div>
<div class="line">        <span class="keywordflow">if</span> (tile_x &lt; 0 || tile_x &gt;= 64 || tile_y &lt; 0 || tile_y &gt;= 64) {</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Convert TileInfo to 16-bit word</span></div>
<div class="line">        uint16_t word = <a class="code hl_function" href="../../d0/d27/namespaceyaze_1_1gfx.html#a66b9ad66f02a591afa773753724ea892">TileInfoToWord</a>(tile16.tiles_info[sub]);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Set in correct layer</span></div>
<div class="line">        <span class="keywordtype">bool</span> is_bg2 = (obj.layer_ == RoomObject::LayerType::BG2);</div>
<div class="line">        <span class="keyword">auto</span>&amp; buffer = is_bg2 ? bg2 : bg1;</div>
<div class="line">        buffer.SetTileAt(tile_x, tile_y, word);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceyaze_1_1gfx_html_a66b9ad66f02a591afa773753724ea892"><div class="ttname"><a href="../../d0/d27/namespaceyaze_1_1gfx.html#a66b9ad66f02a591afa773753724ea892">yaze::gfx::TileInfoToWord</a></div><div class="ttdeci">uint16_t TileInfoToWord(TileInfo tile_info)</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d73/snes__tile_8cc_source.html#l00291">snes_tile.cc:291</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md572"></a>
Palette System</h1>
<h2><a class="anchor" id="autotoc_md573"></a>
Palette Hierarchy</h2>
<div class="fragment"><div class="line">ROM Palette Data</div>
<div class="line">│</div>
<div class="line">├─ dungeon_main[palette_group_id]</div>
<div class="line">│   └─ Large palette (180 colors)</div>
<div class="line">│       └─ Split into PaletteGroup:</div>
<div class="line">│           ├─ palette(0): Main dungeon palette</div>
<div class="line">│           ├─ palette(1): Alternate palette 1</div>
<div class="line">│           └─ palette(2-n): More palettes</div>
<div class="line">│</div>
<div class="line">└─ sprites_aux1[palette_id]</div>
<div class="line">    └─ Sprite auxiliary palettes</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md574"></a>
Palette Loading Flow</h2>
<div class="fragment"><div class="line"><span class="comment">// In DungeonEditor::Load()</span></div>
<div class="line"><span class="keyword">auto</span> dungeon_pal_group = rom-&gt;palette_group().dungeon_main;</div>
<div class="line">full_palette_ = dungeon_pal_group[current_palette_group_id_];</div>
<div class="line"><a class="code hl_define" href="../../d4/d9e/macro_8h.html#a9a548e9537ecb0675b887fec6654d2d3">ASSIGN_OR_RETURN</a>(current_palette_group_,</div>
<div class="line">                 CreatePaletteGroupFromLargePalette(full_palette_));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In DungeonCanvasViewer::LoadAndRenderRoomGraphics()</span></div>
<div class="line"><span class="keyword">auto</span> dungeon_palette_ptr = rom-&gt;paletteset_ids[room.palette][0];</div>
<div class="line"><span class="keyword">auto</span> palette_id = rom-&gt;ReadWord(0xDEC4B + dungeon_palette_ptr);</div>
<div class="line">current_palette_group_id_ = palette_id.value() / 180;</div>
<div class="line">full_palette = rom-&gt;palette_group().dungeon_main[current_palette_group_id_];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply to graphics sheets</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {  <span class="comment">// BG1 layers</span></div>
<div class="line">  <span class="keywordtype">int</span> block = room.blocks()[i];</div>
<div class="line">  Arena::Get().gfx_sheets()[block].SetPaletteWithTransparent(</div>
<div class="line">      current_palette_group_[current_palette_id_], 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 8; i &lt; 16; i++) {  <span class="comment">// BG2 layers (sprites)</span></div>
<div class="line">  <span class="keywordtype">int</span> block = room.blocks()[i];</div>
<div class="line">  Arena::Get().gfx_sheets()[block].SetPaletteWithTransparent(</div>
<div class="line">      sprites_aux1_pal_group[current_palette_id_], 0);</div>
<div class="line">}</div>
<div class="ttc" id="amacro_8h_html_a9a548e9537ecb0675b887fec6654d2d3"><div class="ttname"><a href="../../d4/d9e/macro_8h.html#a9a548e9537ecb0675b887fec6654d2d3">ASSIGN_OR_RETURN</a></div><div class="ttdeci">#define ASSIGN_OR_RETURN(type_variable_name, expression)</div><div class="ttdef"><b>Definition</b> <a href="../../d4/d9e/macro_8h_source.html#l00061">macro.h:61</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md576"></a>
Appendix: Blank Canvas Bug - Detailed Root Cause Analysis</h1>
<p>This section, merged from <code>dungeon_canvas_blank_fix.md</code>, details the investigation and resolution of the blank canvas bug.</p>
<h2><a class="anchor" id="autotoc_md577"></a>
Problem</h2>
<p>The DungeonEditor canvas displayed as blank white despite the rendering pipeline appearing to execute correctly.</p>
<h2><a class="anchor" id="autotoc_md578"></a>
Diagnostic Output Analysis</h2>
<p>Using a comprehensive diagnostic system, the data flow was traced through 8 steps. Steps 1-6 (ROM loading, buffer population, bitmap creation, texture creation) were all passing. The failure was in Step 7.</p>
<h3><a class="anchor" id="autotoc_md579"></a>
❌ Step 7: PALETTE MISSING</h3>
<div class="fragment"><div class="line">=== Step 7: Palette ===</div>
<div class="line">  Palette size: 0 colors  ❌❌❌ ROOT CAUSE!</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md580"></a>
Root Cause Analysis</h2>
<p>Three distinct issues were identified and fixed in sequence:</p>
<h3><a class="anchor" id="autotoc_md581"></a>
Cause 1: Missing Palette Application</h3>
<p><b>The palette was never applied to the bitmap objects!</b> The bitmaps contained indexed pixel data (e.g., color indices 8, 9, 12), but without a color palette, SDL couldn't map these indices to actual colors, resulting in a blank texture.</p>
<p><b>The Fix (Location: <code><a class="el" href="../../d5/d1b/room_8cc.html">src/app/zelda3/dungeon/room.cc</a>:319-322</code>)</b>: Added <code>SetPaletteWithTransparent()</code> calls to the bitmaps <em>before</em> creating the SDL textures. This ensures the renderer has the color information it needs.</p>
<div class="fragment"><div class="line"><span class="comment">// CRITICAL: Apply palette to bitmaps BEFORE creating/updating textures</span></div>
<div class="line">bg1_bmp.SetPaletteWithTransparent(bg1_palette, 0);</div>
<div class="line">bg2_bmp.SetPaletteWithTransparent(bg1_palette, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now create/update textures (palette is already set in bitmap)</span></div>
<div class="line">Renderer::Get().CreateAndRenderBitmap(..., bg1_bmp, bg1_palette);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md582"></a>
Cause 2: All Black Canvas (Incorrect Tile Word)</h3>
<p>After the first fix, the canvas was all black. This was because <code>DrawFloor()</code> was only passing the tile ID to the background buffer, losing the crucial palette information.</p>
<p><b>The Fix</b>: Converted the <code>TileInfo</code> struct to a full 16-bit word (which includes palette bits) before writing it to the buffer.</p>
<div class="fragment"><div class="line"><span class="comment">// CORRECT: Convert TileInfo to word with all metadata</span></div>
<div class="line">uint16_t word1 = gfx::TileInfoToWord(floorTile1);</div>
<div class="line">SetTileAt((xx * 4), (yy * 2), word1);  <span class="comment">// ✅ Now includes palette!</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md583"></a>
Cause 3: Wrong Palette (All Rooms Look "Gargoyle-y")</h3>
<p>After the second fix, all rooms rendered, but with the same incorrect palette (from the first dungeon).</p>
<p><b>The Fix</b>: Used the room's specific <code>palette</code> ID loaded from the ROM header instead of hardcoding palette index <code>0</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ CORRECT: Use the room&#39;s palette ID</span></div>
<div class="line"><span class="keyword">auto</span> bg1_palette =</div>
<div class="line">    rom()-&gt;mutable_palette_group()-&gt;get_group(<span class="stringliteral">&quot;dungeon_main&quot;</span>)[0].palette(palette);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md584"></a>
Key Takeaway</h2>
<p><b>Always apply a palette to indexed-color bitmaps before creating SDL textures.</b> The rendering pipeline requires this step to translate color indices into visible pixels. Each subsequent fix ensured the <em>correct</em> palette information was being passed at each stage. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
