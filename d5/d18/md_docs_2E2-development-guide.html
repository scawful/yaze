<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>yaze: E2 - Development Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../yaze.ico"/></td>
  <td id="projectalign">
   <div id="projectname">yaze<span id="projectnumber">&#160;0.3.2</span>
   </div>
   <div id="projectbrief">Link to the Past ROM Editor</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/d18/md_docs_2E2-development-guide.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">E2 - Development Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md508"></a> This guide outlines the core architectural patterns, UI systems, and best practices for developing and maintaining the yaze editor.</p>
<h1><a class="anchor" id="autotoc_md509"></a>
Editor Status</h1>
<ul>
<li><b>Overworld Editor</b>: Production ready</li>
<li><b>Message Editor</b>: Production ready (requires testing of recent rendering fixes)</li>
<li><b>Emulator</b>: Production ready</li>
<li><b>Dungeon Editor</b>: EXPERIMENTAL - Requires thorough testing</li>
<li><b>Graphics Editor</b>: EXPERIMENTAL - Recent rendering pipeline changes need validation</li>
<li><b>Palette Editor</b>: Production ready</li>
<li><b>Sprite Editor</b>: EXPERIMENTAL</li>
<li><b>Assembly Editor</b>: Production ready</li>
</ul>
<h1><a class="anchor" id="autotoc_md510"></a>
1. Core Architectural Patterns</h1>
<p>These patterns, established during the Overworld Editor refactoring, should be applied to all new and existing editor components.</p>
<h2><a class="anchor" id="autotoc_md511"></a>
Pattern 1: Modular Systems</h2>
<p><b>Principle</b>: Decompose large, monolithic editor classes into smaller, single-responsibility modules.</p>
<ul>
<li><b>Rendering</b>: All drawing logic should be extracted into dedicated <code>*Renderer</code> classes (e.g., <code>OverworldEntityRenderer</code>). The main editor class should delegate drawing calls, not implement them.</li>
<li><b>UI Panels</b>: Complex UI panels should be managed by their own classes (e.g., <code>MapPropertiesSystem</code>), which then communicate with the parent editor via callbacks.</li>
<li><b>Interaction</b>: Canvas interaction logic (mouse handling, editing modes) should be separated from the main editor class to simplify state management.</li>
</ul>
<p><b>Benefit</b>: Smaller, focused modules are easier to test, debug, and maintain. The main editor class becomes a coordinator, which is a much cleaner architecture.</p>
<h2><a class="anchor" id="autotoc_md512"></a>
Pattern 2: Callback-Based Communication</h2>
<p><b>Principle</b>: Use <code>std::function</code> callbacks for child-to-parent communication to avoid circular dependencies.</p>
<ul>
<li><b>Implementation</b>: A parent editor provides its child components with callbacks (typically via a <code>SetCallbacks</code> method) during initialization. The child component invokes these callbacks to notify the parent of events or to request actions (like a refresh).</li>
<li><b>Example</b>: <code>MapPropertiesSystem</code> receives a <code>RefreshCallback</code> from <code>OverworldEditor</code>. When a property is changed in the UI, it calls the function, allowing the <code>OverworldEditor</code> to execute the refresh logic without the <code>MapPropertiesSystem</code> needing to know anything about the editor itself.</li>
</ul>
<h2><a class="anchor" id="autotoc_md513"></a>
Pattern 3: Centralized Progressive Loading via &lt;tt&gt;gfx::Arena&lt;/tt&gt;</h2>
<p><b>Principle</b>: All expensive asset loading operations must be performed asynchronously to prevent UI freezes. The <code>gfx::Arena</code> singleton provides a centralized, priority-based system for this.</p>
<ul>
<li><b>How it Works</b>:<ol type="1">
<li><b>Queue</b>: Instead of loading a texture directly, queue it with the arena: <code>gfx::Arena::Get().QueueDeferredTexture(bitmap, priority);</code></li>
<li><b>Prioritize</b>: Assign a numerical priority. Lower numbers are higher priority. Use a high priority for assets the user is currently viewing and a low priority for assets that can be loaded in the background.</li>
<li><b>Process</b>: In the main <code>Update()</code> loop of an editor, process a small batch of textures each frame: <code>auto batch = gfx::Arena::Get().GetNextDeferredTextureBatch(4, 2);</code> (e.g., 4 high-priority, 2 low-priority).</li>
</ol>
</li>
<li><b>Benefit</b>: This provides a globally consistent, non-blocking loading mechanism that is available to all editors and ensures the UI remains responsive.</li>
</ul>
<h1><a class="anchor" id="autotoc_md514"></a>
2. UI &amp; Theming System</h1>
<p>To ensure a consistent and polished look and feel, all new UI components must adhere to the established theme and helper function system.</p>
<h2><a class="anchor" id="autotoc_md515"></a>
2.1. The Theme System (&lt;tt&gt;AgentUITheme&lt;/tt&gt;)</h2>
<ul>
<li><b>Principle</b>: <b>Never use hardcoded colors (<code>ImVec4</code>)**. All UI colors must be derived from the central theme.</b></li>
<li><b> <b>Implementation</b>: The <code>AgentUITheme</code> system (<code><a class="el" href="../../d3/d4c/agent__ui__theme_8h.html">src/app/editor/agent/agent_ui_theme.h</a></code>) provides a struct of semantic color names (e.g., <code>panel_bg_color</code>, <code>status_success</code>, <code>provider_ollama</code>). These colors are automatically derived from the application's current <code>ThemeManager</code>.</b></li>
<li><p class="startli"><b> **Usage</b>: Fetch the theme at the beginning of a draw call and use the semantic colors:</p>
<p class="startli"><code>cpp const auto&amp; theme = AgentUI::GetTheme(); ImGui::PushStyleColor(ImGuiCol_ChildBg, theme.panel_bg_color); </code></p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md516"></a>
2.2. Reusable UI Helper Functions</h2>
<ul>
<li><b>Principle</b>: Encapsulate common UI patterns into helper functions to reduce boilerplate and ensure consistency.</li>
<li><b>Available Helpers</b> (in <code>AgentUI</code> and <code>gui</code> namespaces):<ul>
<li><b>Panels</b>: <code>AgentUI::PushPanelStyle()</code> / <code>PopPanelStyle()</code></li>
<li><b>Headers</b>: <code>AgentUI::RenderSectionHeader(icon, label, color)</code></li>
<li><b>Indicators</b>: <code>AgentUI::RenderStatusIndicator()</code> (status dot), <code>AgentUI::StatusBadge()</code> (colored text badge).</li>
<li><b>Buttons</b>: <code>AgentUI::StyledButton()</code>, <code>AgentUI::IconButton()</code>.</li>
<li><b>Layout</b>: <code>AgentUI::VerticalSpacing()</code>, <code>AgentUI::HorizontalSpacing()</code>.</li>
</ul>
</li>
<li><b>Benefit</b>: Creates a consistent visual language and makes the UI code far more readable and maintainable.</li>
</ul>
<h2><a class="anchor" id="autotoc_md517"></a>
2.3. Toolbar Implementation (&lt;tt&gt;CompactToolbar&lt;/tt&gt;)</h2>
<ul>
<li><b>Stretching</b>: To prevent <a class="el" href="../../df/de4/namespaceImGui.html">ImGui</a> from stretching the last item in a toolbar, do not use <code>ImGui::BeginGroup()</code>. Instead, manage layout with <code>ImGui::SameLine()</code> and end the toolbar with <code>ImGui::NewLine()</code>.</li>
<li><b>Separators</b>: Use <code>ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical)</code> for vertical separators that do not affect item layout.</li>
<li><b>Property Inputs</b>: Use the <code>toolbar.AddProperty()</code> method for consistent spacing and sizing of input fields within the toolbar.</li>
</ul>
<h1><a class="anchor" id="autotoc_md518"></a>
3. Key System Implementations &amp; Gotchas</h1>
<h2><a class="anchor" id="autotoc_md519"></a>
3.1. Graphics Refresh Logic</h2>
<ul>
<li><b>Immediate vs. Deferred</b>: When a visual property changes, the texture must be updated on the GPU immediately. Use <code>Renderer::Get().RenderBitmap()</code> for an immediate, blocking update. <code>UpdateBitmap()</code> is deferred and should not be used for changes the user expects to see instantly.</li>
<li><b>Call Order is Critical</b>: When a property affecting graphics is changed, the correct sequence of operations is crucial:<ol type="1">
<li>Update the property in the data model.</li>
<li>Call the relevant <code>Load*()</code> method (e.g., <code>map.LoadAreaGraphics()</code>) to load the new data from the ROM into memory.</li>
<li>Force a redraw/re-render of the bitmap.</li>
</ol>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md520"></a>
3.2. Multi-Area Map Configuration</h2>
<ul>
<li><b>Use the Helper</b>: When changing a map's area size (e.g., from <code>Small</code> to <code>Large</code>), you <b>must</b> use the <code>zelda3::Overworld::ConfigureMultiAreaMap()</code> method. Do not set the <code>area_size</code> property directly.</li>
<li><b>Why</b>: This method correctly handles the complex logic of assigning parent IDs to all sibling maps and updating the necessary ROM data for persistence. Failure to use it will result in inconsistent state and refresh bugs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md521"></a>
3.3. Version-Specific Feature Gating</h2>
<ul>
<li><b>Principle</b>: The UI must adapt to the features supported by the loaded ROM. Do not show UI for features that are not available.</li>
<li><b>Implementation</b>: Check the ROM's <code>asm_version</code> byte before rendering a UI component. If the feature is not supported, display a helpful message (e.g., "This feature requires ZSCustomOverworld v3+") instead of the UI.</li>
</ul>
<h2><a class="anchor" id="autotoc_md522"></a>
3.4. Entity Visibility for Visual Testing</h2>
<ul>
<li><b>Standard</b>: All overworld entity markers (entrances, exits, items, sprites) should be rendered with a high-contrast color and an alpha of <code>0.85f</code> to ensure they are clearly visible against any background.<ul>
<li><b>Entrances</b>: Bright yellow-gold</li>
<li><b>Exits</b>: Cyan-white</li>
<li><b>Items</b>: Bright red</li>
<li><b>Sprites</b>: Bright magenta</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md523"></a>
4. Debugging and Testing</h1>
<h2><a class="anchor" id="autotoc_md524"></a>
4.1. Quick Debugging with Startup Flags</h2>
<p>To accelerate your debugging workflow, use command-line flags to jump directly to specific editors and open relevant UI cards:</p>
<div class="fragment"><div class="line"># Quick dungeon room testing</div>
<div class="line">./yaze --rom_file=zelda3.sfc --editor=Dungeon --cards=&quot;Room 0&quot;</div>
<div class="line"> </div>
<div class="line"># Compare multiple rooms</div>
<div class="line">./yaze --rom_file=zelda3.sfc --editor=Dungeon --cards=&quot;Room 0,Room 1,Room 105&quot;</div>
<div class="line"> </div>
<div class="line"># Full dungeon workspace</div>
<div class="line">./yaze --rom_file=zelda3.sfc --editor=Dungeon \</div>
<div class="line">  --cards=&quot;Rooms List,Room Matrix,Object Editor,Palette Editor&quot;</div>
<div class="line"> </div>
<div class="line"># Enable debug logging</div>
<div class="line">./yaze --debug --log_file=debug.log --rom_file=zelda3.sfc --editor=Dungeon</div>
</div><!-- fragment --><p><b>Available Editors</b>: Assembly, Dungeon, Graphics, Music, Overworld, Palette, Screen, Sprite, Message, Hex, Agent, Settings</p>
<p><b>Dungeon Editor Cards</b>: Rooms List, Room Matrix, Entrances List, Room Graphics, Object Editor, Palette Editor, Room N (where N is room ID 0-319)</p>
<p>See debugging-startup-flags.md for complete documentation.</p>
<h2><a class="anchor" id="autotoc_md525"></a>
4.2. Testing Strategies</h2>
<p>For a comprehensive overview of debugging tools and testing strategies, including how to use the logging framework, command-line test runners, and the GUI automation harness for AI agents, please refer to the <a class="el" href="../../de/dc5/md_docs_2E5-debugging-guide.html">Debugging and Testing Guide</a>.</p>
<p>When working with bitmaps and textures, understand that two memory locations must stay synchronized:</p>
<ol type="1">
<li>**<code>data_</code> vector**: C++ std::vector&lt;uint8_t&gt; holding pixel data</li>
<li>**<code>surface_-&gt;pixels</code>**: SDL surface's raw pixel buffer (used for texture creation)</li>
</ol>
<p><b>Critical Rules</b>:</p><ul>
<li>Use <code>set_data()</code> for bulk data replacement (syncs both vector and surface)</li>
<li>Use <code>WriteToPixel()</code> for single-pixel modifications</li>
<li>Never assign directly to <code>mutable_data()</code> for replacements (only updates vector, not surface)</li>
<li>Always call <code>ProcessTextureQueue()</code> every frame to process pending texture operations</li>
</ul>
<p><b>Example</b>: </p><div class="fragment"><div class="line"><span class="comment">// WRONG - only updates vector</span></div>
<div class="line">bitmap.mutable_data() = new_data;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CORRECT - updates both vector and SDL surface</span></div>
<div class="line">bitmap.set_data(new_data);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md526"></a>
3.6. Graphics Sheet Management</h2>
<p>Graphics sheets (223 total) are managed centrally by <code>gfx::Arena</code>. When modifying a sheet:</p>
<ol type="1">
<li>Modify the sheet: <code>auto&amp; sheet = Arena::Get().mutable_gfx_sheet(index);</code></li>
<li>Notify Arena: <code>Arena::Get().NotifySheetModified(index);</code></li>
<li>Changes automatically propagate to all editors</li>
</ol>
<p>Default palettes are applied during ROM loading based on sheet index:</p><ul>
<li>Sheets 0-112: Dungeon main palettes</li>
<li>Sheets 113-127: Sprite palettes</li>
<li>Sheets 128-222: HUD/menu palettes</li>
</ul>
<h2><a class="anchor" id="autotoc_md527"></a>
Naming Conventions</h2>
<ul>
<li>Load: Reading data from ROM into memory</li>
<li>Render: Processing graphics data into bitmaps/textures (CPU pixel operations)</li>
<li>Draw: Displaying textures/shapes on canvas via <a class="el" href="../../df/de4/namespaceImGui.html">ImGui</a> (GPU rendering)</li>
<li>Update: UI state changes, property updates, input handling </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
