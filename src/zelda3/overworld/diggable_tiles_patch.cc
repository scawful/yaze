#include "zelda3/overworld/diggable_tiles_patch.h"

#include <fstream>
#include <iomanip>
#include <sstream>

#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"

namespace yaze::zelda3 {

namespace {

// Vanilla bytes at $1BBDF4 - first instruction of diggable check
// CMP.w #$0034 = $C9 $34 $00
constexpr uint8_t kVanillaBytes[] = {0xC9, 0x34, 0x00};

std::string FormatAddress(uint32_t addr) {
  return absl::StrFormat("$%06X", addr);
}

std::string FormatByte(uint8_t byte) {
  return absl::StrFormat("$%02X", byte);
}

}  // namespace

std::string DiggableTilesPatch::GeneratePatch(
    const DiggableTiles& diggable_tiles,
    const DiggableTilesPatchConfig& config) {
  std::ostringstream asm_code;

  // Header comment
  asm_code << "; =============================================================================\n";
  asm_code << "; Diggable Tiles Table Patch\n";
  asm_code << "; Generated by yaze - Yet Another Zelda3 Editor\n";
  asm_code << "; =============================================================================\n";
  asm_code << "; Replaces hardcoded diggable tile checks with bitfield table lookup.\n";
  asm_code << "; Each Map16 tile ID (0-511) has one bit indicating diggability.\n";
  asm_code << "; =============================================================================\n\n";

  asm_code << "lorom\n\n";

  if (config.use_zs_compatible_mode) {
    asm_code << GenerateZSCompatibleRoutine(diggable_tiles, config);
  } else {
    asm_code << GenerateVanillaRoutine(diggable_tiles, config);
  }

  return asm_code.str();
}

std::string DiggableTilesPatch::GenerateVanillaRoutine(
    const DiggableTiles& diggable_tiles,
    const DiggableTilesPatchConfig& config) {
  std::ostringstream asm_code;

  // Hook at original location
  asm_code << "; Hook the original diggable tile check\n";
  asm_code << "org " << FormatAddress(config.hook_address) << "\n";
  asm_code << "  JSL DiggableTileCheck\n";
  asm_code << "  NOP                     ; Pad remaining bytes\n";
  asm_code << "  NOP\n";
  asm_code << "  NOP\n\n";

  // New routine in freespace
  asm_code << "; New diggable tile lookup routine\n";
  asm_code << "org " << FormatAddress(config.freespace_address) << "\n";
  asm_code << "DiggableTileCheck:\n";
  asm_code << "  PHX                     ; Save X register\n";
  asm_code << "  PHY                     ; Save Y register\n";
  asm_code << "  \n";
  asm_code << "  ; Get tile ID from $7E2000,X (already in A from caller)\n";
  asm_code << "  LDA $7E2000,X\n";
  asm_code << "  AND #$01FF              ; Mask to 9 bits (0-511)\n";
  asm_code << "  \n";
  asm_code << "  ; Calculate byte index: tile_id / 8\n";
  asm_code << "  LSR A\n";
  asm_code << "  LSR A\n";
  asm_code << "  LSR A\n";
  asm_code << "  TAX                     ; X = byte index\n";
  asm_code << "  \n";
  asm_code << "  ; Calculate bit position: tile_id % 8\n";
  asm_code << "  LDA $7E2000,X           ; Reload tile ID (lost after shifts)\n";
  asm_code << "  AND #$0007              ; Get bit position (0-7)\n";
  asm_code << "  TAY                     ; Y = bit position\n";
  asm_code << "  \n";
  asm_code << "  ; Load bit mask from lookup table\n";
  asm_code << "  LDA BitMaskTable,Y\n";
  asm_code << "  AND #$00FF              ; Ensure 8-bit mask\n";
  asm_code << "  STA $00                 ; Store mask in scratch\n";
  asm_code << "  \n";
  asm_code << "  ; Load byte from diggable table and test bit\n";
  asm_code << "  LDA DiggableTilesTable,X\n";
  asm_code << "  AND #$00FF              ; Ensure 8-bit\n";
  asm_code << "  AND $00                 ; Test bit\n";
  asm_code << "  \n";
  asm_code << "  PLY                     ; Restore Y\n";
  asm_code << "  PLX                     ; Restore X\n";
  asm_code << "  \n";
  asm_code << "  BEQ .not_diggable\n";
  asm_code << "  \n";
  asm_code << "  ; Tile is diggable - jump to handler\n";
  asm_code << "  JML " << FormatAddress(config.diggable_handler) << "\n";
  asm_code << "  \n";
  asm_code << ".not_diggable:\n";
  asm_code << "  ; Tile is not diggable - continue normal flow\n";
  asm_code << "  JML " << FormatAddress(config.exit_address) << "\n";
  asm_code << "\n";

  // Bit mask lookup table
  asm_code << "; Bit mask table for positions 0-7\n";
  asm_code << "BitMaskTable:\n";
  asm_code << "  db $01, $02, $04, $08, $10, $20, $40, $80\n\n";

  // Data table
  asm_code << GenerateDataTable(diggable_tiles, config.table_address);

  return asm_code.str();
}

std::string DiggableTilesPatch::GenerateZSCompatibleRoutine(
    const DiggableTiles& diggable_tiles,
    const DiggableTilesPatchConfig& config) {
  std::ostringstream asm_code;

  asm_code << "; ZSCustomOverworld Compatible Mode\n";
  asm_code << "; This patch works alongside ZScream modifications\n\n";

  // For ZS compatibility, we hook differently and chain to existing handlers
  asm_code << "; Extended hook point for ZS compatibility\n";
  asm_code << "org " << FormatAddress(config.freespace_address) << "\n";
  asm_code << "DiggableTileCheck_ZS:\n";
  asm_code << "  ; ZS-compatible lookup routine\n";
  asm_code << "  ; Check our table first, then fall through to ZS handling\n";
  asm_code << "  PHX\n";
  asm_code << "  PHY\n";
  asm_code << "  \n";
  asm_code << "  LDA $7E2000,X\n";
  asm_code << "  AND #$01FF\n";
  asm_code << "  \n";
  asm_code << "  ; Calculate byte index\n";
  asm_code << "  LSR A\n";
  asm_code << "  LSR A\n";
  asm_code << "  LSR A\n";
  asm_code << "  TAX\n";
  asm_code << "  \n";
  asm_code << "  ; Get bit position\n";
  asm_code << "  LDA $7E2000,X\n";
  asm_code << "  AND #$0007\n";
  asm_code << "  TAY\n";
  asm_code << "  \n";
  asm_code << "  ; Test diggable bit\n";
  asm_code << "  LDA BitMaskTable_ZS,Y\n";
  asm_code << "  AND DiggableTilesTable,X\n";
  asm_code << "  \n";
  asm_code << "  PLY\n";
  asm_code << "  PLX\n";
  asm_code << "  \n";
  asm_code << "  BEQ .not_diggable_zs\n";
  asm_code << "  JML " << FormatAddress(config.diggable_handler) << "\n";
  asm_code << ".not_diggable_zs:\n";
  asm_code << "  JML " << FormatAddress(config.exit_address) << "\n";
  asm_code << "\n";

  asm_code << "BitMaskTable_ZS:\n";
  asm_code << "  db $01, $02, $04, $08, $10, $20, $40, $80\n\n";

  asm_code << GenerateDataTable(diggable_tiles, config.table_address);

  return asm_code.str();
}

std::string DiggableTilesPatch::GenerateDataTable(
    const DiggableTiles& diggable_tiles,
    uint32_t table_address) {
  std::ostringstream asm_code;

  asm_code << "; Diggable tiles bitfield table (64 bytes = 512 bits)\n";
  asm_code << "; Each bit represents a Map16 tile ID (0-511)\n";
  asm_code << "org " << FormatAddress(table_address) << "\n";
  asm_code << "DiggableTilesTable:\n";

  const auto& data = diggable_tiles.GetRawData();

  // Write data in rows of 16 bytes
  for (int row = 0; row < 4; ++row) {
    asm_code << "  db ";
    for (int col = 0; col < 16; ++col) {
      int idx = row * 16 + col;
      asm_code << FormatByte(data[idx]);
      if (col < 15) {
        asm_code << ", ";
      }
    }
    asm_code << "  ; Tiles " << (row * 128) << "-" << ((row + 1) * 128 - 1) << "\n";
  }

  asm_code << "\n";

  // Add comment showing which tiles are diggable
  auto diggable_ids = diggable_tiles.GetAllDiggableTileIds();
  if (!diggable_ids.empty()) {
    asm_code << "; Currently marked diggable: ";
    for (size_t i = 0; i < diggable_ids.size(); ++i) {
      if (i > 0) asm_code << ", ";
      asm_code << absl::StrFormat("$%03X", diggable_ids[i]);
      if (i > 0 && (i + 1) % 10 == 0 && i < diggable_ids.size() - 1) {
        asm_code << "\n;                          ";
      }
    }
    asm_code << "\n";
  }

  return asm_code.str();
}

absl::Status DiggableTilesPatch::ExportPatchFile(
    const DiggableTiles& diggable_tiles,
    const std::string& output_path,
    const DiggableTilesPatchConfig& config) {
  std::string patch_content = GeneratePatch(diggable_tiles, config);

  std::ofstream file(output_path);
  if (!file.is_open()) {
    return absl::InternalError(
        absl::StrCat("Failed to open file for writing: ", output_path));
  }

  file << patch_content;
  file.close();

  if (file.fail()) {
    return absl::InternalError(
        absl::StrCat("Failed to write patch file: ", output_path));
  }

  return absl::OkStatus();
}

bool DiggableTilesPatch::DetectZSDiggingHooks(const Rom& rom) {
  // Check if the bytes at the vanilla hook address match vanilla code
  // Vanilla: CMP.w #$0034 = $C9 $34 $00
  if (!rom.is_loaded()) {
    return false;
  }

  // Convert SNES address to ROM offset for LoROM
  // Bank $1B = ROM offset 0x0D8000 (bank $1B - $80) * 0x8000
  // $1BBDF4 in LoROM: ((0x1B & 0x7F) * 0x8000) + (0xBDF4 - 0x8000)
  //                 = (0x1B * 0x8000) + 0x3DF4
  //                 = 0x0D8000 + 0x3DF4 = 0xDBDF4
  constexpr uint32_t rom_offset = 0xDBDF4;

  if (rom_offset + sizeof(kVanillaBytes) > rom.size()) {
    return false;
  }

  // Check if bytes match vanilla using direct data access
  const auto& data = rom.data();
  for (size_t i = 0; i < sizeof(kVanillaBytes); ++i) {
    if (data[rom_offset + i] != kVanillaBytes[i]) {
      // Bytes differ from vanilla - ZS or other patch detected
      return true;
    }
  }

  return false;  // Bytes match vanilla, no ZS hooks detected
}

DiggableTilesPatchConfig DiggableTilesPatch::GetRecommendedConfig(
    const Rom& rom) {
  DiggableTilesPatchConfig config;

  if (DetectZSDiggingHooks(rom)) {
    config.use_zs_compatible_mode = true;
    // Adjust freespace for ZS compatibility
    config.freespace_address = 0x1BF800;  // Different location to avoid conflicts
  }

  return config;
}

}  // namespace yaze::zelda3
