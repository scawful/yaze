#include "app/editor/agent/panels/feature_flag_editor_panel.h"

#include <algorithm>
#include <cctype>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <sstream>

#include "absl/strings/str_format.h"
#include "app/gui/core/icons.h"
#include "app/gui/core/style_guard.h"
#include "core/project.h"
#include "imgui/imgui.h"

namespace yaze {
namespace editor {

namespace {

// Status indicator colors
constexpr ImVec4 kColorEnabled(0.2f, 0.8f, 0.2f, 1.0f);   // Green
constexpr ImVec4 kColorDisabled(0.8f, 0.2f, 0.2f, 1.0f);   // Red
constexpr ImVec4 kColorDirty(0.9f, 0.7f, 0.1f, 1.0f);      // Yellow
constexpr ImVec4 kColorInfo(0.6f, 0.6f, 0.6f, 1.0f);        // Gray

// Header comment block for the generated file
constexpr const char* kFileHeader =
    "; Feature override flags (for isolation testing).\n"
    "; Set to 1 to enable a feature, 0 to disable it.\n"
    "; This file is included after Util/macros.asm and overrides defaults.\n"
    "; Generated by yaze Feature Flag Editor.\n\n";

bool ContainsCaseInsensitive(const std::string& haystack,
                             const std::string& needle) {
  if (needle.empty()) return true;
  auto it = std::search(
      haystack.begin(), haystack.end(), needle.begin(), needle.end(),
      [](char a, char b) {
        return std::tolower(static_cast<unsigned char>(a)) ==
               std::tolower(static_cast<unsigned char>(b));
      });
  return it != haystack.end();
}

}  // namespace

FeatureFlagEditorPanel::FeatureFlagEditorPanel() = default;
FeatureFlagEditorPanel::~FeatureFlagEditorPanel() = default;

void FeatureFlagEditorPanel::Draw() {
  if (!project_) {
    ImGui::TextDisabled("No project loaded.");
    ImGui::TextWrapped(
        "Open a yaze project with a hack_manifest.json to view feature flags.");
    return;
  }

  const auto& manifest = project_->hack_manifest;
  if (!manifest.loaded()) {
    ImGui::TextDisabled("No hack manifest loaded.");
    ImGui::TextWrapped(
        "The project does not have a hack_manifest.json, or it failed to "
        "load. Check the project settings to configure the manifest path.");
    return;
  }

  // Refresh local copy if needed
  if (needs_refresh_) {
    RefreshFromManifest();
    needs_refresh_ = false;
  }

  // Header info
  ImGui::TextColored(ImVec4(0.7f, 0.7f, 1.0f, 1.0f), ICON_MD_FLAG " %s",
                     manifest.hack_name().c_str());
  ImGui::SameLine();
  ImGui::TextDisabled("(%d flags)", static_cast<int>(flags_.size()));

  // Config file path
  std::string config_path = ResolveConfigPath();
  if (!config_path.empty()) {
    ImGui::TextDisabled("Config: %s", config_path.c_str());
  }

  ImGui::Separator();

  // Toolbar: filter + actions
  float save_width = ImGui::CalcTextSize(ICON_MD_SAVE " Save").x +
                     ImGui::GetStyle().FramePadding.x * 2.0f;
  float refresh_width = ImGui::CalcTextSize(ICON_MD_REFRESH " Refresh").x +
                        ImGui::GetStyle().FramePadding.x * 2.0f;
  float filter_width = ImGui::GetContentRegionAvail().x - save_width -
                       refresh_width - ImGui::GetStyle().ItemSpacing.x * 2.0f;

  ImGui::SetNextItemWidth(std::max(100.0f, filter_width));
  ImGui::InputTextWithHint("##flag_filter", "Filter flags...", filter_text_,
                           IM_ARRAYSIZE(filter_text_));
  ImGui::SameLine();

  // Count dirty flags
  int dirty_count = 0;
  for (const auto& flag : flags_) {
    if (flag.dirty) dirty_count++;
  }

  {
    std::optional<gui::StyleColorGuard> dirty_guard;
    if (dirty_count > 0) {
      dirty_guard.emplace(ImGuiCol_Button, kColorDirty);
    }
    if (ImGui::Button(
            absl::StrFormat(ICON_MD_SAVE " Save%s",
                            dirty_count > 0
                                ? absl::StrFormat(" (%d)", dirty_count)
                                : "")
                .c_str())) {
      if (SaveToFile()) {
        status_message_ = "Saved feature flags successfully.";
        status_is_error_ = false;
        // Mark all as clean
        for (auto& flag : flags_) {
          flag.dirty = false;
        }
      } else {
        status_is_error_ = true;
        // status_message_ already set by SaveToFile()
      }
    }
  }

  ImGui::SameLine();
  if (ImGui::Button(ICON_MD_REFRESH " Refresh")) {
    needs_refresh_ = true;
    status_message_ = "Refreshed from manifest.";
    status_is_error_ = false;
  }

  // Status message
  if (!status_message_.empty()) {
    ImVec4 color = status_is_error_ ? kColorDisabled : kColorEnabled;
    ImGui::TextColored(color, "%s", status_message_.c_str());
  }

  ImGui::Spacing();

  // Flags table
  ImGuiTableFlags table_flags = ImGuiTableFlags_RowBg |
                                ImGuiTableFlags_BordersInnerH |
                                ImGuiTableFlags_SizingStretchProp |
                                ImGuiTableFlags_Resizable;

  if (ImGui::BeginTable("FeatureFlagsTable", 5, table_flags)) {
    ImGui::TableSetupColumn("Toggle", ImGuiTableColumnFlags_WidthFixed, 40.0f);
    ImGui::TableSetupColumn("Flag Name", ImGuiTableColumnFlags_WidthStretch);
    ImGui::TableSetupColumn("Value", ImGuiTableColumnFlags_WidthFixed, 50.0f);
    ImGui::TableSetupColumn("Status", ImGuiTableColumnFlags_WidthFixed, 70.0f);
    ImGui::TableSetupColumn("Source", ImGuiTableColumnFlags_WidthStretch,
                            0.4f);
    ImGui::TableHeadersRow();

    std::string filter(filter_text_);

    for (int i = 0; i < static_cast<int>(flags_.size()); ++i) {
      auto& flag = flags_[i];

      // Apply filter
      if (!filter.empty() &&
          !ContainsCaseInsensitive(flag.name, filter) &&
          !ContainsCaseInsensitive(flag.source, filter)) {
        continue;
      }

      ImGui::PushID(i);
      ImGui::TableNextRow();

      // Toggle checkbox
      ImGui::TableSetColumnIndex(0);
      bool enabled = flag.enabled;
      if (ImGui::Checkbox("##toggle", &enabled)) {
        flag.enabled = enabled;
        flag.value = enabled ? 1 : 0;
        flag.dirty = true;
      }

      // Flag name
      ImGui::TableSetColumnIndex(1);
      if (flag.dirty) {
        ImGui::TextColored(kColorDirty, "%s", flag.name.c_str());
      } else {
        ImGui::TextUnformatted(flag.name.c_str());
      }

      // Value
      ImGui::TableSetColumnIndex(2);
      ImGui::Text("%d", flag.value);

      // Status badge
      ImGui::TableSetColumnIndex(3);
      if (flag.enabled) {
        ImGui::TextColored(kColorEnabled, "ON");
      } else {
        ImGui::TextColored(kColorDisabled, "OFF");
      }
      if (flag.dirty) {
        ImGui::SameLine();
        ImGui::TextColored(kColorDirty, "*");
      }

      // Source
      ImGui::TableSetColumnIndex(4);
      ImGui::TextColored(kColorInfo, "%s", flag.source.c_str());

      ImGui::PopID();
    }

    ImGui::EndTable();
  }

  // Summary
  int enabled_count = 0;
  for (const auto& flag : flags_) {
    if (flag.enabled) enabled_count++;
  }
  ImGui::Separator();
  ImGui::TextDisabled("%d/%d flags enabled", enabled_count,
                      static_cast<int>(flags_.size()));
  if (dirty_count > 0) {
    ImGui::SameLine();
    ImGui::TextColored(kColorDirty, "(%d unsaved changes)", dirty_count);
  }
}

void FeatureFlagEditorPanel::RefreshFromManifest() {
  flags_.clear();

  if (!project_ || !project_->hack_manifest.loaded()) {
    return;
  }

  const auto& manifest_flags = project_->hack_manifest.feature_flags();
  flags_.reserve(manifest_flags.size());

  for (const auto& mf : manifest_flags) {
    EditableFlag ef;
    ef.name = mf.name;
    ef.value = mf.value;
    ef.enabled = mf.enabled;
    ef.source = mf.source;
    ef.dirty = false;
    flags_.push_back(std::move(ef));
  }
}

std::string FeatureFlagEditorPanel::ResolveConfigPath() const {
  if (!project_) return "";

  // Use code_folder from the project to find Config/feature_flags.asm
  if (project_->code_folder.empty()) return "";

  std::string code_path = project_->GetAbsolutePath(project_->code_folder);
  auto candidate =
      std::filesystem::path(code_path) / "Config" / "feature_flags.asm";
  return candidate.string();
}

bool FeatureFlagEditorPanel::SaveToFile() {
  std::string config_path = ResolveConfigPath();
  if (config_path.empty()) {
    status_message_ = "Cannot determine config file path (no code folder set).";
    return false;
  }

  // Ensure the directory exists
  auto parent = std::filesystem::path(config_path).parent_path();
  if (!std::filesystem::exists(parent)) {
    status_message_ =
        absl::StrFormat("Config directory does not exist: %s",
                        parent.string());
    return false;
  }

  // Write to a temporary file, then rename for atomicity
  std::string tmp_path = config_path + ".tmp";
  {
    std::ofstream out(tmp_path);
    if (!out.is_open()) {
      status_message_ =
          absl::StrFormat("Failed to open temp file: %s", tmp_path);
      return false;
    }

    out << kFileHeader;

    // Find the longest flag name for alignment
    size_t max_name_len = 0;
    for (const auto& flag : flags_) {
      max_name_len = std::max(max_name_len, flag.name.size());
    }

    // Write each flag, aligned
    for (const auto& flag : flags_) {
      // Pad the flag name for visual alignment
      std::string padded_name = flag.name;
      while (padded_name.size() < max_name_len) {
        padded_name += ' ';
      }
      out << padded_name << " = " << flag.value << "\n";
    }
  }

  // Atomic rename
  std::error_code ec;
  std::filesystem::rename(tmp_path, config_path, ec);
  if (ec) {
    status_message_ =
        absl::StrFormat("Failed to rename temp file: %s", ec.message());
    // Clean up temp file
    std::filesystem::remove(tmp_path, ec);
    return false;
  }

  return true;
}

}  // namespace editor
}  // namespace yaze
