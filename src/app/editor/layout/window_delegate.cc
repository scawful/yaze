#include "app/editor/layout/window_delegate.h"

#include <filesystem>
#include <fstream>
#include <sstream>

#include "absl/strings/str_format.h"
#include "imgui/imgui.h"
#include "util/platform_paths.h"

namespace yaze {
namespace editor {

void WindowDelegate::ShowAllWindows() {
  // This is a placeholder - actual implementation would need to track
  // all registered windows and set their visibility flags
  printf("[WindowDelegate] ShowAllWindows() - %zu windows registered\n",
         registered_windows_.size());
}

void WindowDelegate::HideAllWindows() {
  // This is a placeholder - actual implementation would need to track
  // all registered windows and set their visibility flags
  printf("[WindowDelegate] HideAllWindows() - %zu windows registered\n",
         registered_windows_.size());
}

void WindowDelegate::ShowWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] ShowWindow: %s\n", window_id.c_str());
    // Actual implementation would set window visibility flag
  }
}

void WindowDelegate::HideWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] HideWindow: %s\n", window_id.c_str());
    // Actual implementation would set window visibility flag
  }
}

void WindowDelegate::ToggleWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] ToggleWindow: %s\n", window_id.c_str());
    // Actual implementation would toggle window visibility flag
  }
}

bool WindowDelegate::IsWindowVisible(const std::string& window_id) const {
  if (!IsWindowRegistered(window_id)) {
    return false;
  }
  // Actual implementation would check window visibility flag
  return true;  // Placeholder
}

void WindowDelegate::FocusWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] FocusWindow: %s\n", window_id.c_str());
    // Actual implementation would bring window to front and focus it
  }
}

void WindowDelegate::MaximizeWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] MaximizeWindow: %s\n", window_id.c_str());
    // Actual implementation would maximize the window
  }
}

void WindowDelegate::RestoreWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] RestoreWindow: %s\n", window_id.c_str());
    // Actual implementation would restore the window from maximized state
  }
}

void WindowDelegate::CenterWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] CenterWindow: %s\n", window_id.c_str());
    // Actual implementation would center the window on screen
  }
}

void WindowDelegate::DockWindow(const std::string& window_id,
                                ImGuiDir dock_direction) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] DockWindow: %s to direction %d\n",
           window_id.c_str(), static_cast<int>(dock_direction));
    // Actual implementation would dock the window
  }
}

void WindowDelegate::UndockWindow(const std::string& window_id) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] UndockWindow: %s\n", window_id.c_str());
    // Actual implementation would undock the window
  }
}

void WindowDelegate::SetDockSpace(const std::string& dock_space_id,
                                  const ImVec2& size) {
  printf("[WindowDelegate] SetDockSpace: %s (%.1f x %.1f)\n",
         dock_space_id.c_str(), size.x, size.y);
  // Actual implementation would create/configure dock space
}

absl::Status WindowDelegate::SaveLayout(const std::string& preset_name) {
  if (preset_name.empty()) {
    return absl::InvalidArgumentError("Layout preset name cannot be empty");
  }

  std::string file_path = GetLayoutFilePath(preset_name);

  try {
    // Create directory if it doesn't exist
    std::filesystem::path dir = std::filesystem::path(file_path).parent_path();
    if (!std::filesystem::exists(dir)) {
      std::filesystem::create_directories(dir);
    }

    // Save layout data (placeholder implementation)
    std::ofstream file(file_path);
    if (!file.is_open()) {
      return absl::InternalError(
          absl::StrFormat("Failed to open layout file: %s", file_path));
    }

    file << "# YAZE Layout Preset: " << preset_name << "\n";
    file << "# Generated by WindowDelegate\n";
    file << "# TODO: Implement actual layout serialization\n";

    file.close();

    printf("[WindowDelegate] Saved layout: %s\n", preset_name.c_str());
    return absl::OkStatus();

  } catch (const std::exception& e) {
    return absl::InternalError(
        absl::StrFormat("Failed to save layout: %s", e.what()));
  }
}

absl::Status WindowDelegate::LoadLayout(const std::string& preset_name) {
  if (preset_name.empty()) {
    return absl::InvalidArgumentError("Layout preset name cannot be empty");
  }

  std::string file_path = GetLayoutFilePath(preset_name);

  try {
    if (!std::filesystem::exists(file_path)) {
      return absl::NotFoundError(
          absl::StrFormat("Layout file not found: %s", file_path));
    }

    std::ifstream file(file_path);
    if (!file.is_open()) {
      return absl::InternalError(
          absl::StrFormat("Failed to open layout file: %s", file_path));
    }

    // Load layout data (placeholder implementation)
    std::string line;
    while (std::getline(file, line)) {
      // TODO: Parse and apply layout data
    }

    file.close();

    printf("[WindowDelegate] Loaded layout: %s\n", preset_name.c_str());
    return absl::OkStatus();

  } catch (const std::exception& e) {
    return absl::InternalError(
        absl::StrFormat("Failed to load layout: %s", e.what()));
  }
}

absl::Status WindowDelegate::ResetLayout() {
  printf("[WindowDelegate] ResetLayout()\n");
  if (ImGui::GetCurrentContext()) {
    ImGui::ClearIniSettings();
  }

  auto ini_path = util::PlatformPaths::GetImGuiIniPath();
  if (ini_path.ok()) {
    std::error_code ec;
    std::filesystem::remove(*ini_path, ec);
    if (ec) {
      printf("[WindowDelegate] Failed to remove ImGui ini: %s\n",
             ec.message().c_str());
    }
  }
  return absl::OkStatus();
}

std::vector<std::string> WindowDelegate::GetAvailableLayouts() const {
  std::vector<std::string> layouts;

  try {
    auto layouts_dir = util::PlatformPaths::GetAppDataSubdirectory("layouts");
    if (!layouts_dir.ok()) {
      return layouts;
    }
    for (const auto& entry :
         std::filesystem::directory_iterator(*layouts_dir)) {
      if (entry.is_regular_file() && entry.path().extension() == ".ini") {
        layouts.push_back(entry.path().stem().string());
      }
    }
  } catch (const std::exception& e) {
    printf("[WindowDelegate] Error scanning layouts: %s\n", e.what());
  }

  return layouts;
}

std::vector<std::string> WindowDelegate::GetVisibleWindows() const {
  std::vector<std::string> visible;
  // TODO: Implement actual visibility checking
  return visible;
}

std::vector<std::string> WindowDelegate::GetHiddenWindows() const {
  std::vector<std::string> hidden;
  // TODO: Implement actual visibility checking
  return hidden;
}

ImVec2 WindowDelegate::GetWindowSize(const std::string& window_id) const {
  if (!IsWindowRegistered(window_id)) {
    return ImVec2(0, 0);
  }
  // TODO: Implement actual size retrieval
  return ImVec2(400, 300);  // Placeholder
}

ImVec2 WindowDelegate::GetWindowPosition(const std::string& window_id) const {
  if (!IsWindowRegistered(window_id)) {
    return ImVec2(0, 0);
  }
  // TODO: Implement actual position retrieval
  return ImVec2(100, 100);  // Placeholder
}

void WindowDelegate::ShowWindowsInCategory(const std::string& category) {
  printf("[WindowDelegate] ShowWindowsInCategory: %s\n", category.c_str());
  // TODO: Implement category-based window showing
}

void WindowDelegate::HideWindowsInCategory(const std::string& category) {
  printf("[WindowDelegate] HideWindowsInCategory: %s\n", category.c_str());
  // TODO: Implement category-based window hiding
}

void WindowDelegate::ShowOnlyWindow(const std::string& window_id) {
  printf("[WindowDelegate] ShowOnlyWindow: %s\n", window_id.c_str());
  // TODO: Implement show-only functionality
}

void WindowDelegate::RegisterWindow(const std::string& window_id,
                                    const std::string& category) {
  WindowInfo info;
  info.id = window_id;
  info.category = category;
  info.is_registered = true;

  registered_windows_[window_id] = info;
  printf("[WindowDelegate] Registered window: %s (category: %s)\n",
         window_id.c_str(), category.c_str());
}

void WindowDelegate::UnregisterWindow(const std::string& window_id) {
  auto it = registered_windows_.find(window_id);
  if (it != registered_windows_.end()) {
    registered_windows_.erase(it);
    printf("[WindowDelegate] Unregistered window: %s\n", window_id.c_str());
  }
}

void WindowDelegate::LoadDeveloperLayout() {
  printf("[WindowDelegate] LoadDeveloperLayout()\n");
  // TODO: Implement developer-specific layout
}

void WindowDelegate::LoadDesignerLayout() {
  printf("[WindowDelegate] LoadDesignerLayout()\n");
  // TODO: Implement designer-specific layout
}

void WindowDelegate::LoadModderLayout() {
  printf("[WindowDelegate] LoadModderLayout()\n");
  // TODO: Implement modder-specific layout
}

void WindowDelegate::LoadMinimalLayout() {
  printf("[WindowDelegate] LoadMinimalLayout()\n");
  // TODO: Implement minimal layout
}

bool WindowDelegate::IsWindowRegistered(const std::string& window_id) const {
  auto it = registered_windows_.find(window_id);
  return it != registered_windows_.end() && it->second.is_registered;
}

std::string WindowDelegate::GetLayoutFilePath(
    const std::string& preset_name) const {
  auto layouts_dir = util::PlatformPaths::GetAppDataSubdirectory("layouts");
  if (layouts_dir.ok()) {
    return (*layouts_dir / absl::StrFormat("%s.ini", preset_name.c_str()))
        .string();
  }
  return absl::StrFormat("yaze_layout_%s.ini", preset_name);
}

void WindowDelegate::ApplyLayoutToWindow(const std::string& window_id,
                                         const std::string& layout_data) {
  if (IsWindowRegistered(window_id)) {
    printf("[WindowDelegate] ApplyLayoutToWindow: %s\n", window_id.c_str());
    // TODO: Implement layout application
  }
}

void WindowDelegate::SaveWorkspaceLayout() {
  std::filesystem::path layout_path = "yaze_workspace.ini";
  auto workspace_dir = util::PlatformPaths::GetAppDataSubdirectory("workspaces");
  if (workspace_dir.ok()) {
    layout_path = *workspace_dir / "yaze_workspace.ini";
  }
  ImGui::SaveIniSettingsToDisk(layout_path.string().c_str());
  printf("[WindowDelegate] Workspace layout saved to %s\n",
         layout_path.string().c_str());
}

void WindowDelegate::LoadWorkspaceLayout() {
  std::filesystem::path layout_path = "yaze_workspace.ini";
  auto workspace_dir = util::PlatformPaths::GetAppDataSubdirectory("workspaces");
  if (workspace_dir.ok()) {
    layout_path = *workspace_dir / "yaze_workspace.ini";
  }
  ImGui::LoadIniSettingsFromDisk(layout_path.string().c_str());
  printf("[WindowDelegate] Workspace layout loaded from %s\n",
         layout_path.string().c_str());
}

void WindowDelegate::ResetWorkspaceLayout() {
  // Request layout rebuild - the actual reset is handled by LayoutManager
  // Do NOT use LoadIniSettingsFromMemory(nullptr) as it causes crashes
  printf("[WindowDelegate] Workspace layout reset requested\n");
}

}  // namespace editor
}  // namespace yaze
