#include "lab/layout_designer/widget_code_generator.h"

#include "absl/strings/str_format.h"
#include "absl/strings/str_replace.h"

namespace yaze {
namespace editor {
namespace layout_designer {

std::string WidgetCodeGenerator::GeneratePanelDrawMethod(
    const PanelDesign& design) {
  std::string code;

  code += absl::StrFormat("// Generated by YAZE Layout Designer\n");
  code += absl::StrFormat("// Panel: %s\n", design.panel_name);
  code += absl::StrFormat("// Generated: <timestamp>\n\n");

  code +=
      absl::StrFormat("void %sPanel::Draw(bool* p_open) {\n", design.panel_id);

  // Generate code for all root widgets
  for (const auto& widget : design.widgets) {
    code += GenerateWidgetCode(*widget, 1);
  }

  code += "}\n";

  return code;
}

std::string WidgetCodeGenerator::GenerateWidgetCode(
    const WidgetDefinition& widget, int indent_level) {
  std::string code;
  std::string indent = GetIndent(indent_level);

  // Add comment with widget ID
  code += indent + absl::StrFormat("// Widget: %s\n", widget.id);

  // Generate code based on widget type
  switch (widget.type) {
    case WidgetType::Text:
    case WidgetType::TextWrapped:
    case WidgetType::TextColored:
    case WidgetType::BulletText:
      code += GenerateTextCode(widget, indent_level);
      break;

    case WidgetType::Button:
    case WidgetType::SmallButton:
      code += GenerateButtonCode(widget, indent_level);
      break;

    case WidgetType::Checkbox:
    case WidgetType::RadioButton:
    case WidgetType::InputText:
    case WidgetType::InputInt:
    case WidgetType::InputFloat:
    case WidgetType::SliderInt:
    case WidgetType::SliderFloat:
      code += GenerateInputCode(widget, indent_level);
      break;

    case WidgetType::BeginTable:
    case WidgetType::EndTable:
    case WidgetType::TableNextRow:
    case WidgetType::TableNextColumn:
      code += GenerateTableCode(widget, indent_level);
      break;

    case WidgetType::Canvas:
      code += GenerateCanvasCode(widget, indent_level);
      break;

    case WidgetType::Separator:
      code += indent + "ImGui::Separator();\n";
      break;

    case WidgetType::SameLine:
      code += indent + "ImGui::SameLine();\n";
      break;

    case WidgetType::Spacing:
      code += indent + "ImGui::Spacing();\n";
      break;

    case WidgetType::NewLine:
      code += indent + "ImGui::NewLine();\n";
      break;

    case WidgetType::BeginGroup:
    case WidgetType::BeginChild:
    case WidgetType::CollapsingHeader:
    case WidgetType::TreeNode:
    case WidgetType::TabBar:
      code += GenerateContainerCode(widget, indent_level);
      break;

    default:
      code += indent + absl::StrFormat("// TODO: Generate code for %s\n",
                                       GetWidgetTypeName(widget.type));
      break;
  }

  // Add same line directive if needed
  if (widget.same_line) {
    code += indent + "ImGui::SameLine();\n";
  }

  code += "\n";
  return code;
}

std::string WidgetCodeGenerator::GenerateMemberVariables(
    const PanelDesign& design) {
  std::string code;
  code += "  // Widget state variables\n";

  for (const auto& widget : design.widgets) {
    std::string var_name = GetVariableName(*widget);

    switch (widget->type) {
      case WidgetType::Checkbox: {
        code += absl::StrFormat("  bool %s = false;\n", var_name);
        break;
      }
      case WidgetType::InputText: {
        auto* buffer_size_prop =
            const_cast<WidgetDefinition&>(*widget).GetProperty("buffer_size");
        int size = buffer_size_prop ? buffer_size_prop->int_value : 256;
        code += absl::StrFormat("  char %s[%d] = {};\n", var_name, size);
        break;
      }
      case WidgetType::InputInt:
      case WidgetType::SliderInt: {
        code += absl::StrFormat("  int %s = 0;\n", var_name);
        break;
      }
      case WidgetType::InputFloat:
      case WidgetType::SliderFloat: {
        code += absl::StrFormat("  float %s = 0.0f;\n", var_name);
        break;
      }
      case WidgetType::ColorEdit:
      case WidgetType::ColorPicker: {
        code += absl::StrFormat("  ImVec4 %s = ImVec4(1,1,1,1);\n", var_name);
        break;
      }
      default:
        break;
    }
  }

  return code;
}

std::string WidgetCodeGenerator::GenerateInitializationCode(
    const PanelDesign& design) {
  std::string code;

  // Generate initialization for input text buffers, etc.
  for (const auto& widget : design.widgets) {
    if (widget->type == WidgetType::InputText) {
      auto* hint_prop =
          const_cast<WidgetDefinition&>(*widget).GetProperty("hint");
      if (hint_prop && !hint_prop->string_value.empty()) {
        std::string var_name = GetVariableName(*widget);
        code += absl::StrFormat("  // Initialize %s hint\n", var_name);
      }
    }
  }

  return code;
}

// Private helper methods

std::string WidgetCodeGenerator::GetIndent(int level) {
  return std::string(level * 2, ' ');
}

std::string WidgetCodeGenerator::EscapeString(const std::string& str) {
  return absl::StrReplaceAll(str, {{"\\", "\\\\"}, {"\"", "\\\""}});
}

std::string WidgetCodeGenerator::GenerateButtonCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);

  auto* label_prop = const_cast<WidgetDefinition&>(widget).GetProperty("label");
  std::string label = label_prop ? label_prop->string_value : "Button";

  auto* size_prop = const_cast<WidgetDefinition&>(widget).GetProperty("size");
  ImVec2 size = size_prop ? size_prop->vec2_value : ImVec2(0, 0);

  if (widget.type == WidgetType::SmallButton) {
    code += ind + absl::StrFormat("if (ImGui::SmallButton(\"%s\")) {\n",
                                  EscapeString(label));
  } else if (size.x != 0 || size.y != 0) {
    code += ind + absl::StrFormat(
                      "if (ImGui::Button(\"%s\", ImVec2(%.1f, %.1f))) {\n",
                      EscapeString(label), size.x, size.y);
  } else {
    code += ind + absl::StrFormat("if (ImGui::Button(\"%s\")) {\n",
                                  EscapeString(label));
  }

  code += ind + "  // TODO: Button callback\n";
  if (!widget.callback_name.empty()) {
    code += ind + absl::StrFormat("  %s();\n", widget.callback_name);
  }
  code += ind + "}\n";

  if (!widget.tooltip.empty()) {
    code += ind + "if (ImGui::IsItemHovered()) {\n";
    code += ind + absl::StrFormat("  ImGui::SetTooltip(\"%s\");\n",
                                  EscapeString(widget.tooltip));
    code += ind + "}\n";
  }

  return code;
}

std::string WidgetCodeGenerator::GenerateTextCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);

  auto* text_prop = const_cast<WidgetDefinition&>(widget).GetProperty("text");
  std::string text = text_prop ? text_prop->string_value : "Text";

  switch (widget.type) {
    case WidgetType::Text:
      code +=
          ind + absl::StrFormat("ImGui::Text(\"%s\");\n", EscapeString(text));
      break;
    case WidgetType::TextWrapped:
      code += ind + absl::StrFormat("ImGui::TextWrapped(\"%s\");\n",
                                    EscapeString(text));
      break;
    case WidgetType::BulletText:
      code += ind + absl::StrFormat("ImGui::BulletText(\"%s\");\n",
                                    EscapeString(text));
      break;
    case WidgetType::TextColored: {
      auto* color_prop =
          const_cast<WidgetDefinition&>(widget).GetProperty("color");
      ImVec4 color = color_prop ? color_prop->color_value : ImVec4(1, 1, 1, 1);
      code +=
          ind +
          absl::StrFormat(
              "ImGui::TextColored(ImVec4(%.2f, %.2f, %.2f, %.2f), \"%s\");\n",
              color.x, color.y, color.z, color.w, EscapeString(text));
      break;
    }
    default:
      break;
  }

  return code;
}

std::string WidgetCodeGenerator::GenerateInputCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);
  std::string var_name = GetVariableName(widget);

  auto* label_prop = const_cast<WidgetDefinition&>(widget).GetProperty("label");
  std::string label = label_prop ? label_prop->string_value : "Input";

  switch (widget.type) {
    case WidgetType::Checkbox:
      code += ind + absl::StrFormat("ImGui::Checkbox(\"%s\", &%s);\n",
                                    EscapeString(label), var_name);
      break;

    case WidgetType::InputText: {
      auto* hint_prop =
          const_cast<WidgetDefinition&>(widget).GetProperty("hint");
      if (hint_prop && !hint_prop->string_value.empty()) {
        code +=
            ind +
            absl::StrFormat(
                "ImGui::InputTextWithHint(\"%s\", \"%s\", %s, sizeof(%s));\n",
                EscapeString(label), EscapeString(hint_prop->string_value),
                var_name, var_name);
      } else {
        code +=
            ind + absl::StrFormat("ImGui::InputText(\"%s\", %s, sizeof(%s));\n",
                                  EscapeString(label), var_name, var_name);
      }
      break;
    }

    case WidgetType::InputInt:
      code += ind + absl::StrFormat("ImGui::InputInt(\"%s\", &%s);\n",
                                    EscapeString(label), var_name);
      break;

    case WidgetType::SliderInt: {
      auto* min_prop = const_cast<WidgetDefinition&>(widget).GetProperty("min");
      auto* max_prop = const_cast<WidgetDefinition&>(widget).GetProperty("max");
      int min_val = min_prop ? min_prop->int_value : 0;
      int max_val = max_prop ? max_prop->int_value : 100;
      code += ind + absl::StrFormat("ImGui::SliderInt(\"%s\", &%s, %d, %d);\n",
                                    EscapeString(label), var_name, min_val,
                                    max_val);
      break;
    }

    default:
      break;
  }

  return code;
}

std::string WidgetCodeGenerator::GenerateTableCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);

  switch (widget.type) {
    case WidgetType::BeginTable: {
      auto* id_prop = const_cast<WidgetDefinition&>(widget).GetProperty("id");
      auto* columns_prop =
          const_cast<WidgetDefinition&>(widget).GetProperty("columns");
      std::string id = id_prop ? id_prop->string_value : "table";
      int columns = columns_prop ? columns_prop->int_value : 2;

      code += ind + absl::StrFormat("if (ImGui::BeginTable(\"%s\", %d)) {\n",
                                    id, columns);

      // Generate children
      for (const auto& child : widget.children) {
        code += GenerateWidgetCode(*child, indent + 1);
      }

      code += ind + "  ImGui::EndTable();\n";
      code += ind + "}\n";
      break;
    }

    case WidgetType::TableNextRow:
      code += ind + "ImGui::TableNextRow();\n";
      break;

    case WidgetType::TableNextColumn:
      code += ind + "ImGui::TableNextColumn();\n";
      break;

    default:
      break;
  }

  return code;
}

std::string WidgetCodeGenerator::GenerateCanvasCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);

  auto* size_prop = const_cast<WidgetDefinition&>(widget).GetProperty("size");
  ImVec2 size = size_prop ? size_prop->vec2_value : ImVec2(300, 200);

  code += ind + absl::StrFormat("// Custom canvas - size: %.0fx%.0f\n", size.x,
                                size.y);
  code += ind + "ImVec2 canvas_pos = ImGui::GetCursorScreenPos();\n";
  code += ind + absl::StrFormat("ImVec2 canvas_size = ImVec2(%.0ff, %.0ff);\n",
                                size.x, size.y);
  code += ind + "ImDrawList* draw_list = ImGui::GetWindowDrawList();\n";
  code += ind + "// TODO: Add custom drawing code here\n";
  code += ind + "ImGui::Dummy(canvas_size);\n";

  return code;
}

std::string WidgetCodeGenerator::GenerateContainerCode(
    const WidgetDefinition& widget, int indent) {
  std::string code;
  std::string ind = GetIndent(indent);

  // TODO: Implement container code generation
  code += ind + absl::StrFormat("// TODO: Container widget: %s\n",
                                GetWidgetTypeName(widget.type));

  return code;
}

std::string WidgetCodeGenerator::GetVariableName(
    const WidgetDefinition& widget) {
  // Convert widget ID to valid C++ variable name
  std::string var_name = widget.id;
  std::replace(var_name.begin(), var_name.end(), '.', '_');
  std::replace(var_name.begin(), var_name.end(), '-', '_');
  var_name += "_";
  return var_name;
}

}  // namespace layout_designer
}  // namespace editor
}  // namespace yaze
