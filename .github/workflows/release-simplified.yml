name: Release-Simplified

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
      - 'v[0-9]+.[0-9]+.[0-9]+-*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (must start with v and follow semantic versioning)'
        required: true
        default: 'v0.3.0'
        type: string

env:
  BUILD_TYPE: Release

jobs:
  validate-and-prepare:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.validate.outputs.tag_name }}
      release_notes: ${{ steps.notes.outputs.content }}
    
    steps:
    - name: Validate tag format
      id: validate
      run: |
        # Determine the tag based on trigger type
        if [[ "${{ github.event_name }}" == "push" ]]; then
          if [[ "${{ github.ref_type }}" != "tag" ]]; then
            echo "❌ Error: Release workflow triggered by push to ${{ github.ref_type }} '${{ github.ref_name }}'"
            echo "This workflow should only be triggered by pushing version tags (v1.2.3)"
            echo "Use: git tag v0.3.0 && git push origin v0.3.0"
            exit 1
          fi
          TAG="${{ github.ref_name }}"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          TAG="${{ github.event.inputs.tag }}"
          if [[ -z "$TAG" ]]; then
            echo "❌ Error: No tag specified for manual workflow dispatch"
            exit 1
          fi
        else
          echo "❌ Error: Unsupported event type: ${{ github.event_name }}"
          exit 1
        fi
        
        echo "Validating tag: $TAG"
        
        # Check if tag follows semantic versioning pattern
        if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
          echo "❌ Error: Tag '$TAG' does not follow semantic versioning format (v1.2.3 or v1.2.3-beta)"
          echo "Valid examples: v0.3.0, v1.0.0, v2.1.3-beta, v1.0.0-rc1"
          echo ""
          echo "To create a proper release:"
          echo "1. Use the helper script: ./scripts/create_release.sh 0.3.0"
          echo "2. Or manually: git tag v0.3.0 && git push origin v0.3.0"
          exit 1
        fi
        
        echo "✅ Tag format is valid: $TAG"
        echo "VALIDATED_TAG=$TAG" >> $GITHUB_ENV
        echo "tag_name=$TAG" >> $GITHUB_OUTPUT
    
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate release notes
      id: release_notes
      run: |
        # Extract release version from validated tag
        VERSION="${VALIDATED_TAG}"
        VERSION_NUM=$(echo "$VERSION" | sed 's/^v//')
        
        # Generate release notes using the dedicated script
        echo "Extracting changelog for version: $VERSION_NUM"
        if python3 scripts/extract_changelog.py "$VERSION_NUM" > release_notes.md; then
          echo "Changelog extracted successfully"
          echo "Release notes content:"
          cat release_notes.md
        else
          echo "Failed to extract changelog, creating default release notes"
          echo "# Yaze $VERSION Release Notes\n\nPlease see the full changelog at docs/C1-changelog.md" > release_notes.md
        fi

    - name: Store release notes
      id: notes
      run: |
        # Store release notes content for later use
        echo "content<<EOF" >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  build-release:
    name: Build Release
    needs: validate-and-prepare
    strategy:
      matrix:
        include:
          - name: "Windows x64"
            os: windows-2022
            vcpkg_triplet: x64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: x64
            artifact_name: "yaze-windows-x64"
            
          - name: "Windows ARM64"
            os: windows-2022
            vcpkg_triplet: arm64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: ARM64
            artifact_name: "yaze-windows-arm64"
            
          - name: "macOS Universal"
            os: macos-14
            vcpkg_triplet: arm64-osx
            artifact_name: "yaze-macos"
            
          - name: "Linux x64"
            os: ubuntu-22.04
            artifact_name: "yaze-linux-x64"

    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    # Platform-specific dependency installation
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          ninja-build \
          pkg-config \
          libglew-dev \
          libxext-dev \
          libwavpack-dev \
          libabsl-dev \
          libboost-all-dev \
          libpng-dev \
          python3-dev \
          libpython3-dev \
          libasound2-dev \
          libpulse-dev \
          libx11-dev \
          libxrandr-dev \
          libxcursor-dev \
          libxinerama-dev \
          libxi-dev

    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        # Install Homebrew dependencies needed for UI tests and full builds
        brew install pkg-config libpng boost abseil ninja gtk+3

    # Set up vcpkg for Windows builds
    - name: Set up vcpkg (Windows)
      if: runner.os == 'Windows'
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: 'c8696863d371ab7f46e213d8f5ca923c4aef2a00'
        runVcpkgInstall: true
        vcpkgJsonGlob: '**/vcpkg.json'
        vcpkgDirectory: '${{ github.workspace }}/vcpkg'
      env:
        VCPKG_FORCE_SYSTEM_BINARIES: 1
        VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
        VCPKG_DISABLE_METRICS: 1
        VCPKG_DEFAULT_TRIPLET: ${{ matrix.vcpkg_triplet }}
        VCPKG_ROOT: ${{ github.workspace }}/vcpkg

    # Configure CMake
    - name: Configure CMake (Linux/macOS)
      if: runner.os != 'Windows'
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_POLICY_VERSION_MINIMUM=3.16 \
          -DYAZE_BUILD_TESTS=OFF \
          -DYAZE_BUILD_EMU=OFF \
          -DYAZE_BUILD_Z3ED=OFF \
          -DYAZE_ENABLE_UI_TESTS=ON \
          -DYAZE_ENABLE_ROM_TESTS=OFF \
          -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF \
          -DYAZE_INSTALL_LIB=OFF \
          -DYAZE_MINIMAL_BUILD=OFF \
          -GNinja

    - name: Configure CMake (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "Configuring CMake for Windows build..."
        
        # Use vcpkg toolchain
        cmake -B build `
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} `
          -DCMAKE_POLICY_VERSION_MINIMUM=3.16 `
          -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" `
          -DYAZE_BUILD_TESTS=OFF `
          -DYAZE_BUILD_EMU=OFF `
          -DYAZE_BUILD_Z3ED=OFF `
          -DYAZE_ENABLE_ROM_TESTS=OFF `
          -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF `
          -DYAZE_INSTALL_LIB=OFF `
          -DYAZE_MINIMAL_BUILD=OFF `
          -G "${{ matrix.cmake_generator }}" `
          -A ${{ matrix.cmake_generator_platform }}
        
        Write-Host "CMake configuration completed successfully"

    # Build
    - name: Build
      run: |
        echo "Building YAZE for ${{ matrix.name }}..."
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel
        echo "Build completed successfully!"

    # Test executable functionality
    - name: Test executable functionality
      shell: bash
      run: |
        set -e
        
        echo "Testing executable for ${{ matrix.name }}..."
        
        # Determine executable path based on platform
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          exePath="build/bin/${{ env.BUILD_TYPE }}/yaze.exe"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          exePath="build/bin/yaze.app/Contents/MacOS/yaze"
        else
          exePath="build/bin/yaze"
        fi
        
        if [ -f "$exePath" ]; then
          echo "✓ Executable found: $exePath"
          
          # Test that it's not the test main
          testResult=$($exePath --help 2>&1 || true)
          exitCode=$?
          
          if echo "$testResult" | grep -q "Google Test\|gtest"; then
            echo "ERROR: Executable is running test main instead of app main!"
            echo "Output: $testResult"
            exit 1
          fi
          
          echo "✓ Executable runs correctly (exit code: $exitCode)"
          
          # Display file info
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            fileSize=$(stat -c%s "$exePath" 2>/dev/null || echo "0")
          else
            fileSize=$(stat -f%z "$exePath" 2>/dev/null || stat -c%s "$exePath" 2>/dev/null || echo "0")
          fi
          fileSizeMB=$(echo "scale=2; $fileSize / 1024 / 1024" | bc -l 2>/dev/null || echo "0")
          echo "Executable size: ${fileSizeMB} MB"
        else
          echo "ERROR: Executable not found at: $exePath"
          exit 1
        fi

    # Package
    - name: Package
      shell: bash
      run: |
        set -e
        echo "Packaging for ${{ matrix.name }}..."
        
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          # Windows packaging
          mkdir -p package
          cp -r build/bin/${{ env.BUILD_TYPE }}/* package/ 2>/dev/null || echo "No Release binaries found, trying Debug..."
          cp -r build/bin/Debug/* package/ 2>/dev/null || echo "No Debug binaries found"
          cp -r assets package/ 2>/dev/null || echo "assets directory not found"
          cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
          cp README.md package/ 2>/dev/null || echo "README.md not found"
          cd package && zip -r ../${{ matrix.artifact_name }}.zip *
          
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          # macOS packaging
          if [ -d "build/bin/yaze.app" ]; then
            echo "Found macOS bundle, using it directly"
            cp -r build/bin/yaze.app ./Yaze.app
            # Add additional resources to the bundle
            cp -r assets "Yaze.app/Contents/Resources/" 2>/dev/null || echo "assets directory not found"
            # Update Info.plist with correct version
            if [ -f "cmake/yaze.plist.in" ]; then
              VERSION_NUM=$(echo "${{ needs.validate-and-prepare.outputs.tag_name }}" | sed 's/^v//')
              sed "s/@yaze_VERSION@/$VERSION_NUM/g" cmake/yaze.plist.in > "Yaze.app/Contents/Info.plist"
            fi
          else
            echo "No bundle found, creating manual bundle"
            mkdir -p "Yaze.app/Contents/MacOS"
            mkdir -p "Yaze.app/Contents/Resources"
            cp build/bin/yaze "Yaze.app/Contents/MacOS/"
            cp -r assets "Yaze.app/Contents/Resources/" 2>/dev/null || echo "assets directory not found"
            # Create Info.plist with correct version
            VERSION_NUM=$(echo "${{ needs.validate-and-prepare.outputs.tag_name }}" | sed 's/^v//')
            cat > "Yaze.app/Contents/Info.plist" <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
          <key>CFBundleExecutable</key>
          <string>yaze</string>
          <key>CFBundleIdentifier</key>
          <string>com.yaze.editor</string>
          <key>CFBundleName</key>
          <string>Yaze</string>
          <key>CFBundleVersion</key>
          <string>$VERSION_NUM</string>
          <key>CFBundleShortVersionString</key>
          <string>$VERSION_NUM</string>
          <key>CFBundlePackageType</key>
          <string>APPL</string>
          </dict>
          </plist>
          EOF
          fi
          
          # Create DMG
          mkdir dmg_staging
          cp -r Yaze.app dmg_staging/
          cp LICENSE dmg_staging/ 2>/dev/null || echo "LICENSE not found"
          cp README.md dmg_staging/ 2>/dev/null || echo "README.md not found"
          cp -r docs dmg_staging/ 2>/dev/null || echo "docs directory not found"
          hdiutil create -srcfolder dmg_staging -format UDZO -volname "Yaze ${{ needs.validate-and-prepare.outputs.tag_name }}" ${{ matrix.artifact_name }}.dmg
          
        else
          # Linux packaging
          mkdir package
          cp build/bin/yaze package/
          cp -r assets package/ 2>/dev/null || echo "assets directory not found"
          cp -r docs package/ 2>/dev/null || echo "docs directory not found"
          cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
          cp README.md package/ 2>/dev/null || echo "README.md not found"
          tar -czf ${{ matrix.artifact_name }}.tar.gz -C package .
        fi
        
        echo "Packaging completed successfully!"

    # Create release with artifacts
    - name: Upload to Release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.validate-and-prepare.outputs.tag_name }}
        name: Yaze ${{ needs.validate-and-prepare.outputs.tag_name }}
        body: ${{ needs.validate-and-prepare.outputs.release_notes }}
        draft: false
        prerelease: ${{ contains(needs.validate-and-prepare.outputs.tag_name, 'beta') || contains(needs.validate-and-prepare.outputs.tag_name, 'alpha') || contains(needs.validate-and-prepare.outputs.tag_name, 'rc') }}
        files: |
          ${{ matrix.artifact_name }}.*

  publish-packages:
    name: Publish Packages
    needs: [validate-and-prepare, build-release]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Announce release
      run: |
        echo "🎉 Yaze ${{ needs.validate-and-prepare.outputs.tag_name }} has been released!"
        echo "📦 Packages are now available for download"
        echo "🔗 Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-and-prepare.outputs.tag_name }}"
