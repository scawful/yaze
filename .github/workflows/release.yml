name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
      - 'v[0-9]+.[0-9]+.[0-9]+-*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (must start with v and follow semantic versioning)'
        required: true
        default: 'v0.3.0'
        type: string

concurrency:
  group: release-${{ github.event_name }}-${{ github.ref_name || github.event.inputs.tag || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: read

env:
  BUILD_TYPE: Release

jobs:
  validate-and-prepare:
    name: Validate & Prepare
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.validate.outputs.tag_name }}
      release_notes: ${{ steps.notes.outputs.content }}

    steps:
      - name: Determine & validate tag
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ github.ref_type }}" != "tag" ]]; then
              echo "Release must be triggered by a tag push (vX.Y.Z)."
              exit 1
            fi
            TAG="${{ github.ref_name }}"
          else
            TAG="${{ github.event.inputs.tag }}"
            [[ -n "${TAG}" ]] || { echo "No tag provided."; exit 1; }
          fi

          echo "Validating tag: ${TAG}"
          if [[ ! "${TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
            echo "Tag '${TAG}' must be semantic: v1.2.3 or v1.2.3-rc1"
            exit 1
          fi

          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"
          echo "VALIDATED_TAG=${TAG}" >> "$GITHUB_ENV"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Generate release notes
        id: gen_notes
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${VALIDATED_TAG#v}"
          if [[ -f scripts/extract_changelog.py ]]; then
            if python3 scripts/extract_changelog.py "${VERSION}" > release_notes.md; then
              echo "Changelog extracted for ${VERSION}"
            else
              cat > release_notes.md <<'EOF'
            # yaze Release Notes

            See docs/C1-changelog.md for full history.
            EOF
                        fi
                      else
                        cat > release_notes.md <<'EOF'
            # yaze Release Notes

            See docs/C1-changelog.md for full history.
            EOF
                      fi
                      echo "---- RELEASE NOTES START ----"
                      cat release_notes.md
                      echo "---- RELEASE NOTES END ----"

                  - name: Store release notes output
                    id: notes
                    shell: bash
                    run: |
          {
            echo 'content<<EOF'
            cat release_notes.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

  build-release:
    name: Build (${{ matrix.name }})
    needs: validate-and-prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Windows x64"
            os: windows-2022
            vcpkg_triplet: x64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: x64
            artifact_name: "yaze-windows-x64"
          - name: "Windows ARM64"
            os: windows-2022
            vcpkg_triplet: arm64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: ARM64
            artifact_name: "yaze-windows-arm64"
          - name: "macOS Universal (x86_64+arm64)"
            os: macos-14
            vcpkg_triplet: arm64-osx
            artifact_name: "yaze-macos"
          - name: "Linux x64"
            os: ubuntu-22.04
            artifact_name: "yaze-linux-x64"

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # ---------- Speed: ccache on Unix ----------
      - name: Install ccache (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ccache

      - name: Install ccache (macOS)
        if: runner.os == 'macOS'
        run: brew install ccache

      - name: Cache ccache
        if: runner.os != 'Windows'
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: ccache-${{ runner.os }}-${{ hashFiles('**/CMakeLists.txt', '**/*.cmake') }}
          restore-keys: |
            ccache-${{ runner.os }}-

      # ---------- Dependencies ----------
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential ninja-build pkg-config \
            libglew-dev libxext-dev libwavpack-dev \
            libabsl-dev libboost-all-dev libpng-dev \
            python3-dev libpython3-dev \
            libasound2-dev libpulse-dev \
            libx11-dev libxrandr-dev libxcursor-dev \
            libxinerama-dev libxi-dev

      - name: Install macOS dependencies
        if: runner.os == 'macOS'
        run: |
          brew update
          brew install pkg-config libpng boost abseil ninja gtk+3

      - name: Set up vcpkg (Windows)
        id: vcpkg_setup
        if: runner.os == 'Windows'
        uses: lukka/run-vcpkg@v11
        with:
          # Registry tag 2025.09.17 full commit SHA
          vcpkgGitCommitId: '4334d8b4c8916018600212ab4dd4bbdc343065d1'
          runVcpkgInstall: true
          vcpkgJsonGlob: '**/vcpkg.json'
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
        env:
          VCPKG_FORCE_SYSTEM_BINARIES: 1
          VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
          VCPKG_DISABLE_METRICS: 1
          VCPKG_DEFAULT_TRIPLET: ${{ matrix.vcpkg_triplet }}
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          VCPKG_USE_SYSTEM_BINARIES: 1
          VCPKG_DOWNLOADS: ${{ github.workspace }}/vcpkg_downloads
          VCPKG_DEFAULT_HOST_TRIPLET: x64-windows
          VCPKG_FEATURE_FLAGS: versions

      - name: Mark vcpkg availability
        if: runner.os == 'Windows' && steps.vcpkg_setup.outcome == 'success'
        shell: pwsh
        run: echo "VCPKG_AVAILABLE=true" >> $env:GITHUB_ENV

      - name: Mark minimal build (Windows fallback)
        if: runner.os == 'Windows' && steps.vcpkg_setup.outcome != 'success'
        shell: pwsh
        run: |
          echo "VCPKG_AVAILABLE=false" >> $env:GITHUB_ENV
          echo "YAZE_MINIMAL_BUILD=ON" >> $env:GITHUB_ENV

      # ---------- Configure ----------
      - name: Configure CMake (Linux)
        if: runner.os == 'Linux'
        run: |
          rm -rf build && mkdir -p build
          cmake -S . -B build \
            -GNinja \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_POLICY_VERSION_MINIMUM=3.16 \
            -DYAZE_BUILD_TESTS=ON \
            -DYAZE_BUILD_EMU=OFF \
            -DYAZE_BUILD_Z3ED=ON \
            -DYAZE_ENABLE_UI_TESTS=ON \
            -DYAZE_ENABLE_ROM_TESTS=OFF \
            -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF \
            -DYAZE_INSTALL_LIB=OFF \
            -DYAZE_MINIMAL_BUILD=OFF \
            -DCMAKE_C_COMPILER_LAUNCHER=ccache \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache

      - name: Configure CMake (macOS universal2)
        if: runner.os == 'macOS'
        run: |
          rm -rf build && mkdir -p build
          cmake -S . -B build \
            -GNinja \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_POLICY_VERSION_MINIMUM=3.16 \
            -DYAZE_BUILD_TESTS=ON \
            -DYAZE_BUILD_EMU=OFF \
            -DYAZE_BUILD_Z3ED=ON \
            -DYAZE_ENABLE_UI_TESTS=ON \
            -DYAZE_ENABLE_ROM_TESTS=OFF \
            -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF \
            -DYAZE_INSTALL_LIB=OFF \
            -DYAZE_MINIMAL_BUILD=OFF \
            -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64" \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0

      - name: Configure CMake (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path build) { Remove-Item -Recurse -Force build }
          New-Item -ItemType Directory -Path build | Out-Null

          $toolchain = Join-Path $env:VCPKG_ROOT 'scripts\buildsystems\vcpkg.cmake'
          $useVcpkg = (Test-Path $toolchain) -and ($env:VCPKG_AVAILABLE -ne 'false')

          $args = @(
            '-S','.',
            '-B','build',
            '-G','${{ matrix.cmake_generator }}',
            '-A','${{ matrix.cmake_generator_platform }}',
            '-DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}',
            '-DCMAKE_POLICY_VERSION_MINIMUM=3.16',
            '-DYAZE_BUILD_TESTS=OFF',
            '-DYAZE_BUILD_EMU=OFF',
            '-DYAZE_ENABLE_ROM_TESTS=OFF',
            '-DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF',
            '-DYAZE_INSTALL_LIB=OFF'
          )

          if ($useVcpkg) {
            $args += "-DCMAKE_TOOLCHAIN_FILE=$toolchain"
            $args += '-DYAZE_MINIMAL_BUILD=OFF'
          } else {
            $args += '-DYAZE_MINIMAL_BUILD=ON'
          }

          cmake @args

      # ---------- Build ----------
      - name: Build
        shell: bash
        run: cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

      # ---------- Smoke test ----------
      - name: Test executable
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            EXE="build/bin/${{ env.BUILD_TYPE }}/yaze.exe"
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            EXE="build/bin/yaze.app/Contents/MacOS/yaze"
          else
            EXE="build/bin/yaze"
          fi
          [[ -f "$EXE" ]] || { echo "Executable not found: $EXE"; exit 1; }
          out="$("$EXE" --help || true)"
          if echo "$out" | grep -Ei 'Google Test|gtest' >/dev/null; then
            echo "Executable is test main, expected app main."
            exit 1
          fi
          ls -lh "$EXE"

      - name: Verify universal binary (macOS)
        if: runner.os == 'macOS'
        run: |
          APP="build/bin/yaze.app/Contents/MacOS/yaze"
          [[ -f "$APP" ]] || { echo "Missing $APP"; exit 1; }
          lipo -info "$APP"
          lipo -archs "$APP" | grep -q "x86_64" || { echo "x86_64 slice missing"; exit 1; }
          lipo -archs "$APP" | grep -q "arm64"  || { echo "arm64 slice missing"; exit 1; }

      # ---------- Package ----------
      - name: Package
        shell: bash
        run: |
          set -euo pipefail
          ART="${{ matrix.artifact_name }}"
          case "${{ runner.os }}" in
            Windows)
              cmake --build build --config ${{ env.BUILD_TYPE }} --target package || true
              pkg="$(ls build/yaze-*.zip 2>/dev/null | head -n1 || true)"
              if [[ -n "${pkg}" ]]; then
                cp "${pkg}" "${ART}.zip"
              else
                mkdir -p package
                cp -r "build/bin/${{ env.BUILD_TYPE }}"/* package/
                [[ -d assets ]] && cp -r assets package/
                [[ -f LICENSE ]] && cp LICENSE package/
                [[ -f README.md ]] && cp README.md package/
                (cd package && powershell.exe -NoLogo -NoProfile -Command "Compress-Archive -Path * -DestinationPath ../${ART}.zip -Force")
              fi
              ;;
            macOS)
              ver="${{ needs.validate-and-prepare.outputs.tag_name }}"
              ver="${ver#v}"
              chmod +x ./scripts/create-macos-bundle.sh
              ./scripts/create-macos-bundle.sh "${ver}" "${ART}"
              ;;
            Linux)
              mkdir -p package
              cp build/bin/yaze package/
              [[ -d assets ]] && cp -r assets package/
              [[ -d docs ]] && cp -r docs package/
              [[ -f LICENSE ]] && cp LICENSE package/
              [[ -f README.md ]] && cp README.md package/
              tar -czf "${ART}.tar.gz" -C package .
              ;;
          esac
          echo "Package artifacts:"
          ls -lh ${ART}.zip ${ART}.tar.gz 2>/dev/null || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            ${{ matrix.artifact_name }}.zip
            ${{ matrix.artifact_name }}.tar.gz
          if-no-files-found: ignore
          retention-days: 7

  create-release:
    name: Create GitHub Release
    needs: [validate-and-prepare, build-release]
    runs-on: ubuntu-latest
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Summarize artifacts
        shell: bash
        run: |
          echo "Artifacts downloaded:"
          find dist -maxdepth 2 -type f -print -exec ls -lh {} \;

      - name: Create/Update Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-and-prepare.outputs.tag_name }}
          name: yaze ${{ needs.validate-and-prepare.outputs.tag_name }}
          body: ${{ needs.validate-and-prepare.outputs.release_notes }}
          draft: false
          prerelease: ${{ contains(needs.validate-and-prepare.outputs.tag_name, 'beta') || contains(needs.validate-and-prepare.outputs.tag_name, 'alpha') || contains(needs.validate-and-prepare.outputs.tag_name, 'rc') }}
          files: |
            dist/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-packages:
    name: Publish Packages (announce)
    needs: [validate-and-prepare, create-release]
    runs-on: ubuntu-latest
    steps:
      - name: Announce release
        run: |
          echo "ðŸŽ‰ yaze ${{ needs.validate-and-prepare.outputs.tag_name }} has been released!"
          echo "ðŸ“¦ Packages are now available for download"
          echo "ðŸ”— Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-and-prepare.outputs.tag_name }}"