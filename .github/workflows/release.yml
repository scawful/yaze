# .github/workflows/release.yml

name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
      - 'v[0-9]+.[0-9]+.[0-9]+-*' # e.g., v1.2.3-beta, v1.2.3-rc1
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.3.0)'
        required: true
        type: string

concurrency:
  group: release-${{ github.ref_name || github.event.inputs.tag }}
  cancel-in-progress: true

permissions:
  contents: write

env:
  BUILD_TYPE: Release

jobs:
  # ======================================================================================
  #  VALIDATE & PREPARE RELEASE
  # ======================================================================================
  prepare-release:
    name: "✅ Validate & Prepare"
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.validate.outputs.tag_name }}
      release_notes: ${{ steps.notes.outputs.content }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}

    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for changelog extraction

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: "Determine & Validate Tag"
        id: validate
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "push" ]]; then
            TAG="${{ github.ref_name }}"
          else
            TAG="${{ github.event.inputs.tag }}"
          fi

          echo "Validating tag: ${TAG}"
          if [[ ! "${TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
            echo "::error::Tag '${TAG}' must follow semantic versioning (e.g., v1.2.3 or v1.2.3-beta)."
            exit 1
          fi

          # Determine if it's a pre-release
          if [[ "${TAG}" =~ - ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
          fi

          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"
          echo "VALIDATED_TAG=${TAG}" >> "$GITHUB_ENV"
          echo "✅ Tag is valid and processed."

      - name: "Generate Release Notes"
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${VALIDATED_TAG#v}"

          if [[ -f scripts/extract_changelog.py ]]; then
            echo "Attempting to extract changelog for version ${VERSION}..."
            python3 scripts/extract_changelog.py "${VERSION}" > release_notes.md
          else
            echo "::warning::'scripts/extract_changelog.py' not found. Creating default release notes."
            echo "# Yaze ${{ env.VALIDATED_TAG }} Release Notes" > release_notes.md
            echo "" >> release_notes.md
            echo "For a detailed list of changes, please see the project's commit history or changelog file." >> release_notes.md
          fi

          echo "Generated release notes:"
          cat release_notes.md

      - name: "Store Release Notes"
        id: notes
        shell: bash
        run: |
          {
            echo 'content<<EOF'
            cat release_notes.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

  # ======================================================================================
  #  BUILD & PACKAGE
  # ======================================================================================
  build-and-package:
    name: "📦 Build (${{ matrix.name }})"
    needs: prepare-release
    continue-on-error: true  # PRE-1.0: Don't block release on platform failure
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Windows x64"
            os: windows-2022
            artifact_name: "yaze-windows-x64"
          - name: "macOS arm64"
            os: macos-14
            mac_arch: arm64
            artifact_name: "yaze-macos-arm64-slice"
          - name: "macOS x86_64"
            os: macos-14
            mac_arch: x86_64
            artifact_name: "yaze-macos-x86_64-slice"
          - name: "Linux x64"
            os: ubuntu-22.04
            artifact_name: "yaze-linux-x64"

    runs-on: ${{ matrix.os }}

    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: "Set up vcpkg (Windows only)"
        if: runner.os == 'Windows'
        uses: lukka/run-vcpkg@v11
        id: vcpkg
        continue-on-error: true
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '01f602195983451bc83e72f4214af2cbc495aa94'  # 2024.10.21 release
          runVcpkgInstall: true

      - name: "Retry vcpkg setup (Windows only)"
        if: runner.os == 'Windows' && steps.vcpkg.outcome == 'failure'
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '01f602195983451bc83e72f4214af2cbc495aa94'
          runVcpkgInstall: true
          doNotUpdateVcpkg: true  # Use existing clone on retry

      - name: "Install Dependencies"
        id: deps
        shell: bash
        continue-on-error: true
        run: |
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            sudo apt-get update
            sudo apt-get install -y \
              build-essential ninja-build pkg-config \
              libglew-dev libxext-dev libwavpack-dev libboost-all-dev \
              libpng-dev python3-dev libpython3-dev \
              libasound2-dev libpulse-dev libx11-dev libxrandr-dev libxcursor-dev \
              libxinerama-dev libxi-dev
            # Note: libabsl-dev removed - gRPC uses bundled Abseil via FetchContent when enabled
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            brew install ninja cmake pkg-config
          fi

      - name: "Retry Dependencies (if failed)"
        if: steps.deps.outcome == 'failure'
        shell: bash
        run: |
          echo "::warning::First dependency install failed, retrying..."
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            sudo apt-get clean
            sudo apt-get update --fix-missing
            sudo apt-get install -y \
              build-essential ninja-build pkg-config \
              libglew-dev libxext-dev libwavpack-dev libboost-all-dev \
              libpng-dev python3-dev libpython3-dev \
              libasound2-dev libpulse-dev libx11-dev libxrandr-dev libxcursor-dev \
              libxinerama-dev libxi-dev
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            brew update
            brew install ninja cmake pkg-config
          fi

      - name: "Configure (Windows)"
        if: runner.os == 'Windows'
        id: configure_windows
        shell: pwsh
        run: |
          Write-Host "::group::CMake Configuration (Windows)" -ForegroundColor Cyan

          $vcpkgToolchain = "${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" -replace '\\', '/'
          Write-Host "Using vcpkg toolchain: $vcpkgToolchain"

          cmake -B build -G "Visual Studio 17 2022" -A x64 `
            -DCMAKE_BUILD_TYPE=$env:BUILD_TYPE `
            -DCMAKE_TOOLCHAIN_FILE="$vcpkgToolchain" `
            -DVCPKG_TARGET_TRIPLET=x64-windows-static `
            -DVCPKG_MANIFEST_MODE=ON `
            -DCMAKE_CXX_FLAGS="/Dgoogle_protobuf_undef_DWORD=1" `
            -DYAZE_BUILD_TESTS=ON `
            -DYAZE_ENABLE_ROM_TESTS=OFF 2>&1 | Tee-Object -FilePath cmake_config.log
          # Note: Tests enabled for pre-1.0 releases to catch issues before publishing
          # ROM tests disabled (require test ROM file)

          if ($LASTEXITCODE -ne 0) {
            Write-Host "::error::CMake configuration failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }

          Write-Host "::endgroup::"

      - name: "Configure (macOS)"
        if: runner.os == 'macOS'
        id: configure_macos
        shell: bash
        run: |
          set -e
          echo "::group::CMake Configuration (macOS)"
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_OSX_ARCHITECTURES=${{ matrix.mac_arch }} \
            -DYAZE_BUILD_EMU=OFF \
            -DYAZE_BUILD_TESTS=ON \
            -DYAZE_ENABLE_ROM_TESTS=OFF 2>&1 | tee cmake_config.log
          echo "::endgroup::"
          # Note: YAZE_BUILD_EMU=OFF disables standalone emulator executable
          #       but yaze_emulator library is still built for main app
          # Note: Tests enabled for pre-1.0 releases to catch issues before publishing

      - name: "Configure (Linux)"
        if: runner.os == 'Linux'
        id: configure_linux
        shell: bash
        run: |
          set -e
          echo "::group::CMake Configuration (Linux)"
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DYAZE_BUILD_EMU=OFF \
            -DYAZE_BUILD_TESTS=ON \
            -DYAZE_ENABLE_ROM_TESTS=OFF 2>&1 | tee cmake_config.log
          echo "::endgroup::"
          # Note: YAZE_BUILD_EMU=OFF disables standalone emulator executable
          #       but yaze_emulator library is still built for main app
          # Note: Tests enabled for pre-1.0 releases to catch issues before publishing

      - name: "Report Configure Failure"
        if: |
          failure() &&
          (steps.configure_windows.outcome == 'failure' ||
           steps.configure_macos.outcome == 'failure' ||
           steps.configure_linux.outcome == 'failure')
        shell: bash
        run: |
          echo "::error::CMake configuration failed for ${{ matrix.name }}"
          if [ -f cmake_config.log ]; then
            echo "::group::CMake Configuration Log (last 50 lines)"
            tail -50 cmake_config.log
            echo "::endgroup::"
          fi
          if [ -f build/CMakeFiles/CMakeError.log ]; then
            echo "::group::CMake Error Log"
            cat build/CMakeFiles/CMakeError.log
            echo "::endgroup::"
          fi

      - name: "Build"
        id: build
        run: cmake --build build --config ${{ env.BUILD_TYPE }} --parallel 2>&1 | tee build.log

      - name: "Report Build Failure"
        if: failure() && steps.build.outcome == 'failure'
        shell: bash
        run: |
          echo "::error::Build failed for ${{ matrix.name }}"
          if [ -f build.log ]; then
            echo "::group::Build Log (last 100 lines)"
            tail -100 build.log
            echo "::endgroup::"

            echo "::group::Build Errors"
            grep -i "error" build.log | head -20 || true
            echo "::endgroup::"
          fi

      - name: "Upload Build Logs on Failure"
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: release-build-logs-${{ matrix.artifact_name }}
          path: |
            cmake_config.log
            build.log
            build/CMakeFiles/CMakeError.log
            build/CMakeFiles/CMakeOutput.log
          if-no-files-found: ignore
          retention-days: 7

      - name: "Package Artifacts"
        shell: bash
        run: |
          set -euo pipefail
          ARTIFACT_NAME="${{ matrix.artifact_name }}"

          # Create staging directory
          mkdir -p stage

          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Windows uses Visual Studio generator: build/bin/Release/
            echo "Packaging Windows artifacts..."
            if [[ ! -f build/bin/${{ env.BUILD_TYPE }}/yaze.exe ]]; then
              echo "::error::Windows binary not found at build/bin/${{ env.BUILD_TYPE }}/yaze.exe"
              ls -la build/bin/ || true
              exit 1
            fi
            cp -r build/bin/${{ env.BUILD_TYPE }}/* stage/
            cp -r assets/ stage/assets/
            cp LICENSE README.md stage/
            (cd stage && powershell -Command "Compress-Archive -Path * -DestinationPath ../${ARTIFACT_NAME}.zip")
            echo "Created ${ARTIFACT_NAME}.zip"

          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            # macOS creates app bundle: build/bin/yaze.app
            echo "Packaging macOS artifacts..."
            if [[ ! -d build/bin/yaze.app ]]; then
              echo "::error::macOS app bundle not found at build/bin/yaze.app"
              ls -la build/bin/ || true
              exit 1
            fi
            cp -R build/bin/yaze.app stage/yaze.app
            echo "Staged yaze.app slice for ${ARTIFACT_NAME}"

          else # Linux
            # Linux uses Ninja generator: build/bin/yaze (no subdirectory)
            echo "Packaging Linux artifacts..."
            if [[ -f build/bin/yaze ]]; then
              echo "Found binary at build/bin/yaze"
              cp build/bin/yaze stage/
            else
              echo "::error::Linux binary not found at build/bin/yaze"
              ls -la build/bin/ || true
              exit 1
            fi

            # Copy assets from source tree
            if [[ -d assets ]]; then
              cp -r assets/ stage/assets/
            else
              echo "::error::Assets directory not found"
              exit 1
            fi

            cp LICENSE README.md stage/
            tar -czf "${ARTIFACT_NAME}.tar.gz" -C stage .
            echo "Created ${ARTIFACT_NAME}.tar.gz"
          fi

      - name: "Upload Artifact (Windows)"
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_name }}.zip
          if-no-files-found: error
          retention-days: 5

      - name: "Upload Artifact (macOS)"
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: stage/yaze.app
          if-no-files-found: error
          retention-days: 5

      - name: "Upload Artifact (Linux)"
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_name }}.tar.gz
          if-no-files-found: error
          retention-days: 5

      - name: "Generate Build Summary"
        if: always()
        shell: bash
        run: |
          echo "## Release Build Summary - ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Artifact**: ${{ matrix.artifact_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: ${{ env.BUILD_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          CONFIGURE_OUTCOME="${{ steps.configure_windows.outcome || steps.configure_macos.outcome || steps.configure_linux.outcome }}"
          if [[ "$CONFIGURE_OUTCOME" == "success" ]]; then
            echo "- ✅ Configure: Success" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ❌ Configure: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ steps.build.outcome }}" == "success" ]]; then
            echo "- ✅ Build: Success" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ❌ Build: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Show package size if build succeeded
          if [[ "${{ steps.build.outcome }}" == "success" ]]; then
            if [[ "${{ runner.os }}" == "Windows" && -f "${{ matrix.artifact_name }}.zip" ]]; then
              SIZE=$(du -h "${{ matrix.artifact_name }}.zip" | cut -f1)
              echo "- 📦 Artifact Size: $SIZE" >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ runner.os }}" == "Linux" && -f "${{ matrix.artifact_name }}.tar.gz" ]]; then
              SIZE=$(du -h "${{ matrix.artifact_name }}.tar.gz" | cut -f1)
              echo "- 📦 Artifact Size: $SIZE" >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ runner.os }}" == "macOS" && -d "stage/yaze.app" ]]; then
              SIZE=$(du -sh "stage/yaze.app" | cut -f1)
              echo "- 📦 Artifact Size: $SIZE" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  # ======================================================================================
  #  MERGE MACOS & CREATE UNIVERSAL BINARY
  # ======================================================================================
  merge-macos-universal:
    name: "🍎 Merge macOS Universal"
    needs: build-and-package
    if: always()  # PRE-1.0: Run even if some platform builds failed
    continue-on-error: true  # PRE-1.0: Don't block release if universal merge fails
    runs-on: macos-14
    steps:
      - name: "Download arm64 Slice"
        id: download_arm64
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: yaze-macos-arm64-slice
          path: arm64-slice

      - name: "Download x86_64 Slice"
        id: download_x64
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: yaze-macos-x86_64-slice
          path: x86_64-slice

      - name: "Create Universal Binary"
        shell: bash
        run: |
          set -euo pipefail

          ARM_AVAILABLE=${{ steps.download_arm64.outcome == 'success' }}
          X64_AVAILABLE=${{ steps.download_x64.outcome == 'success' }}

          echo "ARM64 slice available: $ARM_AVAILABLE"
          echo "x86_64 slice available: $X64_AVAILABLE"

          if [[ "$ARM_AVAILABLE" == "false" && "$X64_AVAILABLE" == "false" ]]; then
            echo "::error::No macOS slices available - cannot create macOS release"
            exit 1
          fi

          # The artifacts are downloaded as yaze.app directly
          ARM_APP="arm64-slice/yaze.app"
          X64_APP="x86_64-slice/yaze.app"

          if [[ "$ARM_AVAILABLE" == "true" && "$X64_AVAILABLE" == "true" ]]; then
            echo "Creating universal binary from both architectures..."
            echo "Checking downloaded artifacts..."
            ls -la arm64-slice/
            ls -la x86_64-slice/

            # Use the arm64 bundle as the base
            cp -R "${ARM_APP}" ./yaze.app

            echo "Merging executables..."
            lipo -create "${ARM_APP}/Contents/MacOS/yaze" "${X64_APP}/Contents/MacOS/yaze" -output "./yaze.app/Contents/MacOS/yaze"

            echo "Verifying universal binary..."
            lipo -info "./yaze.app/Contents/MacOS/yaze"

            echo "Creating DMG..."
            hdiutil create -fs HFS+ -srcfolder ./yaze.app -volname "yaze ${{ needs.prepare-release.outputs.tag_name }} (Universal)" yaze-macos-universal.dmg

          elif [[ "$ARM_AVAILABLE" == "true" ]]; then
            echo "::warning::Only ARM64 slice available - creating ARM64-only DMG"
            cp -R "${ARM_APP}" ./yaze.app
            hdiutil create -fs HFS+ -srcfolder ./yaze.app -volname "yaze ${{ needs.prepare-release.outputs.tag_name }} (ARM64)" yaze-macos-arm64.dmg
            mv yaze-macos-arm64.dmg yaze-macos-universal.dmg  # Use same name for upload

          else
            echo "::warning::Only x86_64 slice available - creating x86_64-only DMG"
            cp -R "${X64_APP}" ./yaze.app
            hdiutil create -fs HFS+ -srcfolder ./yaze.app -volname "yaze ${{ needs.prepare-release.outputs.tag_name }} (Intel)" yaze-macos-x86_64.dmg
            mv yaze-macos-x86_64.dmg yaze-macos-universal.dmg  # Use same name for upload
          fi

      - name: "Upload Universal macOS Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: yaze-macos-universal
          path: yaze-macos-universal.dmg
          if-no-files-found: error
          retention-days: 5

  # ======================================================================================
  #  CREATE GITHUB RELEASE
  # ======================================================================================
  create-github-release:
    name: "🚀 Create GitHub Release"
    needs: [prepare-release, build-and-package, merge-macos-universal]
    if: always()  # PRE-1.0: Always run to create release even if some platforms failed
    runs-on: ubuntu-latest
    steps:
      - name: "Download Windows Artifact"
        id: download_windows
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: yaze-windows-x64
          path: release-artifacts

      - name: "Download Linux Artifact"
        id: download_linux
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: yaze-linux-x64
          path: release-artifacts

      - name: "Download macOS Universal Artifact"
        id: download_macos
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: yaze-macos-universal
          path: release-artifacts

      - name: "List Release Artifacts"
        run: ls -lR release-artifacts || echo "No artifacts directory"

      - name: "Generate Platform Availability Report"
        id: platform_report
        shell: bash
        run: |
          echo "Checking which platforms succeeded..."

          WINDOWS_OK=${{ steps.download_windows.outcome == 'success' }}
          LINUX_OK=${{ steps.download_linux.outcome == 'success' }}
          MACOS_OK=${{ steps.download_macos.outcome == 'success' }}

          # Build availability message
          AVAILABILITY="## Platform Availability\n\n"

          if [[ "$WINDOWS_OK" == "true" ]]; then
            AVAILABILITY+="- ✅ **Windows x64**: Available\n"
          else
            AVAILABILITY+="- ❌ **Windows x64**: Build failed (will be added in subsequent release)\n"
          fi

          if [[ "$LINUX_OK" == "true" ]]; then
            AVAILABILITY+="- ✅ **Linux x64**: Available\n"
          else
            AVAILABILITY+="- ❌ **Linux x64**: Build failed (will be added in subsequent release)\n"
          fi

          if [[ "$MACOS_OK" == "true" ]]; then
            AVAILABILITY+="- ✅ **macOS Universal**: Available\n"
          else
            AVAILABILITY+="- ❌ **macOS**: Build failed (will be added in subsequent release)\n"
          fi

          AVAILABILITY+="\n---\n\n"

          # Save to output
          {
            echo 'availability<<EOF'
            echo -e "$AVAILABILITY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          # Check if we have at least one successful build
          if [[ "$WINDOWS_OK" == "false" && "$LINUX_OK" == "false" && "$MACOS_OK" == "false" ]]; then
            echo "::error::All platform builds failed - cannot create release"
            exit 1
          fi

          echo "✅ At least one platform succeeded - release can proceed"

      - name: "Create/Update Release"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag_name }}
          name: "yaze ${{ needs.prepare-release.outputs.tag_name }}"
          body: |
            ${{ steps.platform_report.outputs.availability }}
            ${{ needs.prepare-release.outputs.release_notes }}

            ---

            **Note**: This is a pre-1.0 release. Platforms may be added incrementally.
            You can re-run failed platform jobs to add missing binaries to this release.
          draft: false
          prerelease: ${{ needs.prepare-release.outputs.is_prerelease }}
          files: release-artifacts/*
          fail_on_unmatched_files: false  # Don't fail if some platforms missing
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: "Generate Release Summary"
        if: always()
        shell: bash
        run: |
          echo "## 🚀 Release Created: ${{ needs.prepare-release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.platform_report.outputs.availability }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- If platforms failed, you can re-run those specific jobs" >> $GITHUB_STEP_SUMMARY
          echo "- Failed builds will be added to this same release when re-run succeeds" >> $GITHUB_STEP_SUMMARY
          echo "- The release tag remains the same (${{ needs.prepare-release.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY
