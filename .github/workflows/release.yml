name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
      - 'v[0-9]+.[0-9]+.[0-9]+-*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (must start with v and follow semantic versioning)'
        required: true
        default: 'v0.3.0'
        type: string

env:
  BUILD_TYPE: Release

jobs:
  validate-and-prepare:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.validate.outputs.tag_name }}
      release_notes: ${{ steps.notes.outputs.content }}
    
    steps:
    - name: Validate tag format
      id: validate
      run: |
        # Debug information
        echo "Event name: ${{ github.event_name }}"
        echo "Ref: ${{ github.ref }}"
        echo "Ref name: ${{ github.ref_name }}"
        echo "Ref type: ${{ github.ref_type }}"
        
        # Determine the tag based on trigger type
        if [[ "${{ github.event_name }}" == "push" ]]; then
          if [[ "${{ github.ref_type }}" != "tag" ]]; then
            echo "❌ Error: Release workflow triggered by push to ${{ github.ref_type }} '${{ github.ref_name }}'"
            echo "This workflow should only be triggered by pushing version tags (v1.2.3)"
            echo "Use: git tag v0.3.0 && git push origin v0.3.0"
            exit 1
          fi
          TAG="${{ github.ref_name }}"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          TAG="${{ github.event.inputs.tag }}"
          if [[ -z "$TAG" ]]; then
            echo "❌ Error: No tag specified for manual workflow dispatch"
            exit 1
          fi
        else
          echo "❌ Error: Unsupported event type: ${{ github.event_name }}"
          exit 1
        fi
        
        echo "Validating tag: $TAG"
        
        # Check if tag follows semantic versioning pattern
        if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
          echo "❌ Error: Tag '$TAG' does not follow semantic versioning format (v1.2.3 or v1.2.3-beta)"
          echo "Valid examples: v0.3.0, v1.0.0, v2.1.3-beta, v1.0.0-rc1"
          echo ""
          echo "To create a proper release:"
          echo "1. Use the helper script: ./scripts/create_release.sh 0.3.0"
          echo "2. Or manually: git tag v0.3.0 && git push origin v0.3.0"
          exit 1
        fi
        
        echo "✅ Tag format is valid: $TAG"
        echo "VALIDATED_TAG=$TAG" >> $GITHUB_ENV
        echo "tag_name=$TAG" >> $GITHUB_OUTPUT
    
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate release notes
      id: release_notes
      run: |
        # Extract release version from validated tag
        VERSION="${VALIDATED_TAG}"
        VERSION_NUM=$(echo "$VERSION" | sed 's/^v//')
        
        # Generate release notes using the dedicated script
        echo "Extracting changelog for version: $VERSION_NUM"
        if python3 scripts/extract_changelog.py "$VERSION_NUM" > release_notes.md; then
          echo "Changelog extracted successfully"
          echo "Release notes content:"
          cat release_notes.md
        else
          echo "Failed to extract changelog, creating default release notes"
          echo "# Yaze $VERSION Release Notes\n\nPlease see the full changelog at docs/C1-changelog.md" > release_notes.md
        fi

    - name: Store release notes
      id: notes
      run: |
        # Store release notes content for later use
        echo "content<<EOF" >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  build-release:
    name: Build Release
    needs: validate-and-prepare
    strategy:
      matrix:
        include:
          - name: "Windows x64"
            os: windows-2022
            vcpkg_triplet: x64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: x64
            artifact_name: "yaze-windows-x64"
            artifact_path: "build/bin/Release/"
            package_cmd: |
              mkdir -p package
              cp -r build/bin/Release/* package/ 2>/dev/null || echo "No Release binaries found, trying Debug..."
              cp -r build/bin/Debug/* package/ 2>/dev/null || echo "No Debug binaries found"
              cp -r assets package/ 2>/dev/null || echo "assets directory not found"
              cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
              cp README.md package/ 2>/dev/null || echo "README.md not found"
              cd package && zip -r ../yaze-windows-x64.zip *
            
          - name: "Windows x86"
            os: windows-2022
            vcpkg_triplet: x86-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: Win32
            artifact_name: "yaze-windows-x86"
            artifact_path: "build/bin/Release/"
            package_cmd: |
              mkdir -p package
              cp -r build/bin/Release/* package/ 2>/dev/null || echo "No Release binaries found, trying Debug..."
              cp -r build/bin/Debug/* package/ 2>/dev/null || echo "No Debug binaries found"
              cp -r assets package/ 2>/dev/null || echo "assets directory not found"
              cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
              cp README.md package/ 2>/dev/null || echo "README.md not found"
              cd package && zip -r ../yaze-windows-x86.zip *
            
          - name: "Windows ARM64"
            os: windows-2022
            vcpkg_triplet: arm64-windows
            cmake_generator: "Visual Studio 17 2022"
            cmake_generator_platform: ARM64
            artifact_name: "yaze-windows-arm64"
            artifact_path: "build/bin/Release/"
            package_cmd: |
              mkdir -p package
              cp -r build/bin/Release/* package/ 2>/dev/null || echo "No Release binaries found, trying Debug..."
              cp -r build/bin/Debug/* package/ 2>/dev/null || echo "No Debug binaries found"
              cp -r assets package/ 2>/dev/null || echo "assets directory not found"
              cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
              cp README.md package/ 2>/dev/null || echo "README.md not found"
              cd package && zip -r ../yaze-windows-arm64.zip *
            
          - name: "macOS Universal"
            os: macos-14
            vcpkg_triplet: arm64-osx
            artifact_name: "yaze-macos"
            artifact_path: "build/bin/"
            package_cmd: |
              # Debug: List what was actually built
              echo "Contents of build/bin/:"
              ls -la build/bin/ || echo "build/bin/ does not exist"
              
              # Check if we have a bundle or standalone executable
              if [ -d "build/bin/yaze.app" ]; then
                echo "Found macOS bundle, using it directly"
                # Use the existing bundle and just update it
                cp -r build/bin/yaze.app ./Yaze.app
                # Add additional resources to the bundle
                cp -r assets "Yaze.app/Contents/Resources/" 2>/dev/null || echo "assets directory not found"
                # Update Info.plist with correct version
                if [ -f "cmake/yaze.plist.in" ]; then
                  VERSION_NUM=$(echo "${{ needs.validate-and-prepare.outputs.tag_name }}" | sed 's/^v//')
                  sed "s/@yaze_VERSION@/$VERSION_NUM/g" cmake/yaze.plist.in > "Yaze.app/Contents/Info.plist"
                fi
              else
                echo "No bundle found, creating manual bundle"
                # Create bundle structure manually
                mkdir -p "Yaze.app/Contents/MacOS"
                mkdir -p "Yaze.app/Contents/Resources"
                cp build/bin/yaze "Yaze.app/Contents/MacOS/"
                cp -r assets "Yaze.app/Contents/Resources/" 2>/dev/null || echo "assets directory not found"
                # Create Info.plist with correct version
                if [ -f "cmake/yaze.plist.in" ]; then
                  VERSION_NUM=$(echo "${{ needs.validate-and-prepare.outputs.tag_name }}" | sed 's/^v//')
                  sed "s/@yaze_VERSION@/$VERSION_NUM/g" cmake/yaze.plist.in > "Yaze.app/Contents/Info.plist"
                else
                  # Create a basic Info.plist
                  VERSION_NUM=$(echo "${{ needs.validate-and-prepare.outputs.tag_name }}" | sed 's/^v//')
                  cat > "Yaze.app/Contents/Info.plist" <<EOF
                  <?xml version="1.0" encoding="UTF-8"?>
                  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
                  <plist version="1.0">
                  <dict>
                  <key>CFBundleExecutable</key>
                  <string>yaze</string>
                  <key>CFBundleIdentifier</key>
                  <string>com.yaze.editor</string>
                  <key>CFBundleName</key>
                  <string>Yaze</string>
                  <key>CFBundleVersion</key>
                  <string>$VERSION_NUM</string>
                  <key>CFBundleShortVersionString</key>
                  <string>$VERSION_NUM</string>
                  <key>CFBundlePackageType</key>
                  <string>APPL</string>
                  </dict>
                  </plist>
                  EOF
                fi
              fi
              
              # Create DMG
              mkdir dmg_staging
              cp -r Yaze.app dmg_staging/
              cp LICENSE dmg_staging/ 2>/dev/null || echo "LICENSE not found"
              cp README.md dmg_staging/ 2>/dev/null || echo "README.md not found"
              cp -r docs dmg_staging/ 2>/dev/null || echo "docs directory not found"
              hdiutil create -srcfolder dmg_staging -format UDZO -volname "Yaze ${{ needs.validate-and-prepare.outputs.tag_name }}" yaze-macos.dmg
            
          - name: "Linux x64"
            os: ubuntu-22.04
            artifact_name: "yaze-linux-x64"
            artifact_path: "build/bin/"
            package_cmd: |
              mkdir package
              cp build/bin/yaze package/
              cp -r assets package/ 2>/dev/null || echo "assets directory not found"
              cp -r docs package/ 2>/dev/null || echo "docs directory not found"
              cp LICENSE package/ 2>/dev/null || echo "LICENSE not found"
              cp README.md package/ 2>/dev/null || echo "README.md not found"
              tar -czf yaze-linux-x64.tar.gz -C package .

    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    # Clean up any potential vcpkg issues (Windows only)
    - name: Clean vcpkg state (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "Cleaning up any existing vcpkg state..."
        if (Test-Path "vcpkg") {
          Remove-Item -Recurse -Force "vcpkg" -ErrorAction SilentlyContinue
        }
        if (Test-Path "vcpkg_installed") {
          Remove-Item -Recurse -Force "vcpkg_installed" -ErrorAction SilentlyContinue
        }
        Write-Host "Cleanup completed"

    # Platform-specific dependency installation
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          ninja-build \
          pkg-config \
          libglew-dev \
          libxext-dev \
          libwavpack-dev \
          libabsl-dev \
          libboost-all-dev \
          libpng-dev \
          python3-dev \
          libpython3-dev \
          libasound2-dev \
          libpulse-dev \
          libx11-dev \
          libxrandr-dev \
          libxcursor-dev \
          libxinerama-dev \
          libxi-dev

    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        # Install Homebrew dependencies needed for UI tests and full builds
        brew install pkg-config libpng boost abseil ninja gtk+3

    - name: Setup build environment
      run: |
        echo "Using streamlined release build configuration for all platforms"
        echo "Linux/macOS: UI tests enabled with full dependency support"
        echo "Windows: Full build with vcpkg integration for proper releases"
        echo "All platforms: Emulator and developer tools disabled for clean releases"

    # Configure CMake
    - name: Configure CMake (Linux/macOS)
      if: runner.os != 'Windows'
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_POLICY_VERSION_MINIMUM=3.16 \
          -DYAZE_BUILD_TESTS=OFF \
          -DYAZE_BUILD_EMU=OFF \
          -DYAZE_BUILD_Z3ED=OFF \
          -DYAZE_ENABLE_UI_TESTS=ON \
          -DYAZE_ENABLE_ROM_TESTS=OFF \
          -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF \
          -DYAZE_INSTALL_LIB=OFF \
          -DYAZE_MINIMAL_BUILD=OFF \
          -GNinja

    # Set up vcpkg for Windows builds with fallback
    - name: Set up vcpkg (Windows)
      id: vcpkg_setup
      if: runner.os == 'Windows'
      uses: lukka/run-vcpkg@v11
      continue-on-error: true
      with:
        vcpkgGitCommitId: 'c8696863d371ab7f46e213d8f5ca923c4aef2a00'
        runVcpkgInstall: true
        vcpkgJsonGlob: '**/vcpkg.json'
        vcpkgDirectory: '${{ github.workspace }}/vcpkg'
      env:
        VCPKG_FORCE_SYSTEM_BINARIES: 1
        VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
        VCPKG_DISABLE_METRICS: 1
        VCPKG_DEFAULT_TRIPLET: ${{ matrix.vcpkg_triplet }}
        VCPKG_ROOT: ${{ github.workspace }}/vcpkg

    # Debug vcpkg failure (Windows only)
    - name: Debug vcpkg failure (Windows)
      if: runner.os == 'Windows' && steps.vcpkg_setup.outcome == 'failure'
      shell: pwsh
      run: |
        Write-Host "=== vcpkg Setup Failed - Debug Information ===" -ForegroundColor Red
        Write-Host "vcpkg directory exists: $(Test-Path 'vcpkg')"
        Write-Host "vcpkg_installed directory exists: $(Test-Path 'vcpkg_installed')"
        if (Test-Path "vcpkg") {
          Write-Host "vcpkg directory contents:"
          Get-ChildItem "vcpkg" | Select-Object -First 10
        }
        Write-Host "Git status:"
        git status --porcelain
        Write-Host "=============================================" -ForegroundColor Red

    # Fallback: Install dependencies manually if vcpkg fails
    - name: Install dependencies manually (Windows fallback)
      if: runner.os == 'Windows' && steps.vcpkg_setup.outcome == 'failure'
      shell: pwsh
      run: |
        Write-Host "vcpkg setup failed, installing dependencies manually..."
        
        # Install Chocolatey if not present
        if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
          Write-Host "Installing Chocolatey..."
          Set-ExecutionPolicy Bypass -Scope Process -Force
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
          iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        }
        
        # Install basic build tools and dependencies
        Write-Host "Installing build tools and dependencies..."
        choco install -y cmake ninja git
        
        # Install some basic libraries that might be needed for minimal build
        Write-Host "Installing basic libraries..."
        choco install -y vcpkg --source=chocolatey 2>$null || Write-Host "vcpkg not available via chocolatey, continuing..."
        
        # Try to install some basic dependencies manually
        Write-Host "Setting up basic development environment..."
        $env:Path += ";C:\Program Files\Git\bin"
        
        # Set environment variable to indicate minimal build
        echo "YAZE_MINIMAL_BUILD=ON" >> $env:GITHUB_ENV
        echo "VCPKG_AVAILABLE=false" >> $env:GITHUB_ENV
        
        Write-Host "Manual dependency installation completed"

    # Set vcpkg availability flag when vcpkg succeeds
    - name: Set vcpkg availability flag
      if: runner.os == 'Windows' && steps.vcpkg_setup.outcome == 'success'
      shell: pwsh
      run: |
        echo "VCPKG_AVAILABLE=true" >> $env:GITHUB_ENV
        Write-Host "vcpkg setup successful"

    - name: Configure CMake (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "Configuring CMake for Windows build..."
        
        # Check if vcpkg is available
        if (Test-Path "${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" -and $env:VCPKG_AVAILABLE -ne "false") {
          Write-Host "Using vcpkg toolchain..."
          cmake -B build `
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} `
            -DCMAKE_POLICY_VERSION_MINIMUM=3.16 `
            -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake" `
            -DYAZE_BUILD_TESTS=OFF `
            -DYAZE_BUILD_EMU=OFF `
            -DYAZE_BUILD_Z3ED=OFF `
            -DYAZE_ENABLE_ROM_TESTS=OFF `
            -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF `
            -DYAZE_INSTALL_LIB=OFF `
            -DYAZE_MINIMAL_BUILD=OFF `
            -G "${{ matrix.cmake_generator }}" `
            -A ${{ matrix.cmake_generator_platform }}
        } else {
          Write-Host "Using minimal build configuration (vcpkg not available)..."
          cmake -B build `
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} `
            -DCMAKE_POLICY_VERSION_MINIMUM=3.16 `
            -DYAZE_BUILD_TESTS=OFF `
            -DYAZE_BUILD_EMU=OFF `
            -DYAZE_BUILD_Z3ED=OFF `
            -DYAZE_ENABLE_ROM_TESTS=OFF `
            -DYAZE_ENABLE_EXPERIMENTAL_TESTS=OFF `
            -DYAZE_INSTALL_LIB=OFF `
            -DYAZE_MINIMAL_BUILD=ON `
            -G "${{ matrix.cmake_generator }}" `
            -A ${{ matrix.cmake_generator_platform }}
        }
        
        Write-Host "CMake configuration completed successfully"

    # Verify CMake configuration (Windows only)
    - name: Verify CMake configuration (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "Verifying CMake configuration..."
        if (Test-Path "build/CMakeCache.txt") {
          Write-Host "✓ CMakeCache.txt found"
          Write-Host "Build type: $(Select-String -Path 'build/CMakeCache.txt' -Pattern 'CMAKE_BUILD_TYPE' | ForEach-Object { $_.Line.Split('=')[1] })"
          Write-Host "Minimal build: $(Select-String -Path 'build/CMakeCache.txt' -Pattern 'YAZE_MINIMAL_BUILD' | ForEach-Object { $_.Line.Split('=')[1] })"
        } else {
          Write-Error "CMakeCache.txt not found - CMake configuration failed!"
          exit 1
        }

    # Build
    - name: Build
      run: |
        echo "Building YAZE for ${{ matrix.name }}..."
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel
        echo "Build completed successfully!"

    # Validate Visual Studio project builds (Windows only)
    # Generate yaze_config.h for Visual Studio builds
    - name: Generate yaze_config.h
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $version = "${{ needs.validate-and-prepare.outputs.tag_name }}" -replace '^v', ''
        $versionParts = $version -split '\.'
        $major = if ($versionParts.Length -gt 0) { $versionParts[0] } else { "0" }
        $minor = if ($versionParts.Length -gt 1) { $versionParts[1] } else { "0" }
        $patch = if ($versionParts.Length -gt 2) { $versionParts[2] -split '-' | Select-Object -First 1 } else { "0" }
        
        Write-Host "Generating yaze_config.h with version: $major.$minor.$patch"
        Copy-Item "src\yaze_config.h.in" "yaze_config.h"
        (Get-Content 'yaze_config.h') -replace '@yaze_VERSION_MAJOR@', $major -replace '@yaze_VERSION_MINOR@', $minor -replace '@yaze_VERSION_PATCH@', $patch | Set-Content 'yaze_config.h'
        Write-Host "Generated yaze_config.h:"
        Get-Content 'yaze_config.h'

    - name: Validate Visual Studio Project Build
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Validating Visual Studio Project Build" -ForegroundColor Cyan
        Write-Host "Platform: ${{ matrix.cmake_generator_platform }}" -ForegroundColor Yellow
        Write-Host "Configuration: ${{ env.BUILD_TYPE }}" -ForegroundColor Yellow
        Write-Host "========================================" -ForegroundColor Cyan
        
        # Check if we're in the right directory
        if (-not (Test-Path "yaze.sln")) {
            Write-Error "yaze.sln not found. Please run this script from the project root directory."
            exit 1
        }
        
        Write-Host "✓ yaze.sln found" -ForegroundColor Green
        
        # Build using MSBuild
        Write-Host "Building with MSBuild..." -ForegroundColor Yellow
        $msbuildArgs = @(
            "yaze.sln"
            "/p:Configuration=${{ env.BUILD_TYPE }}"
            "/p:Platform=${{ matrix.cmake_generator_platform }}"
            "/p:VcpkgEnabled=true"
            "/p:VcpkgManifestInstall=true"
            "/m"  # Multi-processor build
            "/verbosity:minimal"
        )
        
        Write-Host "MSBuild command: msbuild $($msbuildArgs -join ' ')" -ForegroundColor Gray
        & msbuild @msbuildArgs
        
        if ($LASTEXITCODE -ne 0) {
            Write-Error "MSBuild failed with exit code $LASTEXITCODE"
            exit 1
        }
        
        Write-Host "✓ Visual Studio build completed successfully" -ForegroundColor Green
        
        # Verify executable was created
        $exePath = "build\bin\${{ env.BUILD_TYPE }}\yaze.exe"
        if (-not (Test-Path $exePath)) {
            Write-Error "Executable not found at expected path: $exePath"
            exit 1
        }
        
        Write-Host "✓ Executable created: $exePath" -ForegroundColor Green
        
        # Test that the executable runs (basic test)
        Write-Host "Testing executable startup..." -ForegroundColor Yellow
        $testResult = & $exePath --help 2>&1
        $exitCode = $LASTEXITCODE
        
        # Check if it's the test main or app main
        if ($testResult -match "Google Test" -or $testResult -match "gtest") {
            Write-Error "Executable is running test main instead of app main!"
            Write-Host "Output: $testResult" -ForegroundColor Red
            exit 1
        }
        
        Write-Host "✓ Executable runs correctly (exit code: $exitCode)" -ForegroundColor Green
        
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "✓ Visual Studio build validation PASSED" -ForegroundColor Green
        Write-Host "========================================" -ForegroundColor Cyan

    # Test executable functionality (Windows)
    - name: Test executable functionality (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        
        # Debug: List build directory contents
        Write-Host "Build directory contents:" -ForegroundColor Cyan
        if (Test-Path "build") {
            Get-ChildItem -Recurse build -Name | Select-Object -First 20
        } else {
            Write-Host "build directory does not exist" -ForegroundColor Red
        }
        
        # Determine executable path for Windows
        $exePath = "build\bin\${{ env.BUILD_TYPE }}\yaze.exe"
        
        if (Test-Path $exePath) {
            Write-Host "✓ Executable found: $exePath" -ForegroundColor Green
            
            # Test that it's not the test main
            $testResult = & $exePath --help 2>&1
            $exitCode = $LASTEXITCODE
            
            if ($testResult -match "Google Test" -or $testResult -match "gtest") {
                Write-Error "Executable is running test main instead of app main!"
                Write-Host "Output: $testResult" -ForegroundColor Red
                exit 1
            }
            
            Write-Host "✓ Executable runs correctly (exit code: $exitCode)" -ForegroundColor Green
            
            # Display file info
            $exeInfo = Get-Item $exePath
            Write-Host "Executable size: $([math]::Round($exeInfo.Length / 1MB, 2)) MB" -ForegroundColor Cyan
        } else {
            Write-Error "Executable not found at: $exePath"
            exit 1
        }

    # Test executable functionality (macOS)
    - name: Test executable functionality (macOS)
      if: runner.os == 'macOS'
      shell: bash
      run: |
        set -e
        
        echo "Build directory contents:"
        if [ -d "build" ]; then
            find build -name "*.app" -o -name "yaze" | head -10
        else
            echo "build directory does not exist"
            exit 1
        fi
        
        # Determine executable path for macOS
        exePath="build/bin/yaze.app/Contents/MacOS/yaze"
        
        if [ -f "$exePath" ]; then
            echo "✓ Executable found: $exePath"
            
            # Test that it's not the test main
            testResult=$($exePath --help 2>&1 || true)
            exitCode=$?
            
            if echo "$testResult" | grep -q "Google Test\|gtest"; then
                echo "ERROR: Executable is running test main instead of app main!"
                echo "Output: $testResult"
                exit 1
            fi
            
            echo "✓ Executable runs correctly (exit code: $exitCode)"
            
            # Display file info
            fileSize=$(stat -f%z "$exePath")
            fileSizeMB=$(echo "scale=2; $fileSize / 1024 / 1024" | bc -l)
            echo "Executable size: ${fileSizeMB} MB"
        else
            echo "ERROR: Executable not found at: $exePath"
            exit 1
        fi

    # Test executable functionality (Linux)
    - name: Test executable functionality (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        set -e
        
        echo "Build directory contents:"
        if [ -d "build" ]; then
            find build -type f -name "yaze" | head -10
        else
            echo "build directory does not exist"
            exit 1
        fi
        
        # Determine executable path for Linux
        exePath="build/bin/yaze"
        
        if [ -f "$exePath" ]; then
            echo "✓ Executable found: $exePath"
            
            # Test that it's not the test main
            testResult=$($exePath --help 2>&1 || true)
            exitCode=$?
            
            if echo "$testResult" | grep -q "Google Test\|gtest"; then
                echo "ERROR: Executable is running test main instead of app main!"
                echo "Output: $testResult"
                exit 1
            fi
            
            echo "✓ Executable runs correctly (exit code: $exitCode)"
            
            # Display file info
            fileSize=$(stat -c%s "$exePath")
            fileSizeMB=$(echo "scale=2; $fileSize / 1024 / 1024" | bc -l)
            echo "Executable size: ${fileSizeMB} MB"
        else
            echo "ERROR: Executable not found at: $exePath"
            exit 1
        fi

    # Verify build artifacts
    - name: Verify build artifacts
      shell: bash
      run: |
        echo "Verifying build artifacts for ${{ matrix.name }}..."
        if [ -d "build/bin" ]; then
          echo "Build directory contents:"
          find build/bin -type f -name "yaze*" -o -name "*.exe" -o -name "*.app" | head -10
        else
          echo "ERROR: build/bin directory not found!"
          exit 1
        fi

    # Package
    - name: Package
      shell: bash
      run: |
        set -e
        echo "Packaging for ${{ matrix.name }}..."
        ${{ matrix.package_cmd }}
        echo "Packaging completed successfully!"

    # Create release with artifacts (will create release if it doesn't exist)
    - name: Upload to Release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.validate-and-prepare.outputs.tag_name }}
        name: Yaze ${{ needs.validate-and-prepare.outputs.tag_name }}
        body: ${{ needs.validate-and-prepare.outputs.release_notes }}
        draft: false
        prerelease: ${{ contains(needs.validate-and-prepare.outputs.tag_name, 'beta') || contains(needs.validate-and-prepare.outputs.tag_name, 'alpha') || contains(needs.validate-and-prepare.outputs.tag_name, 'rc') }}
        files: |
          ${{ matrix.artifact_name }}.*
        fail_on_unmatched_files: false

  publish-packages:
    name: Publish Packages
    needs: [validate-and-prepare, build-release]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Update release status
      run: |
        echo "Release has been published successfully"
        echo "All build artifacts have been uploaded"

    - name: Announce release
      run: |
        echo "🎉 Yaze ${{ needs.validate-and-prepare.outputs.tag_name }} has been released!"
        echo "📦 Packages are now available for download"
        echo "🔗 Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-and-prepare.outputs.tag_name }}"
